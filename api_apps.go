/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnectclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AppsAPIService AppsAPI service
type AppsAPIService service

type ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAlternativeDistributionKeys *[]string
}

// the fields to include for returned resources of type alternativeDistributionKeys
func (r ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest) FieldsAlternativeDistributionKeys(fieldsAlternativeDistributionKeys []string) ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest {
	r.fieldsAlternativeDistributionKeys = &fieldsAlternativeDistributionKeys
	return r
}

func (r ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest) Execute() (*AlternativeDistributionKeyResponse, *http.Response, error) {
	return r.ApiService.AppsAlternativeDistributionKeyGetToOneRelatedExecute(r)
}

/*
AppsAlternativeDistributionKeyGetToOneRelated Method for AppsAlternativeDistributionKeyGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsAlternativeDistributionKeyGetToOneRelated(ctx context.Context, id string) ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest {
	return ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AlternativeDistributionKeyResponse
func (a *AppsAPIService) AppsAlternativeDistributionKeyGetToOneRelatedExecute(r ApiAppsAlternativeDistributionKeyGetToOneRelatedRequest) (*AlternativeDistributionKeyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlternativeDistributionKeyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAlternativeDistributionKeyGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/alternativeDistributionKey"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAlternativeDistributionKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[alternativeDistributionKeys]", r.fieldsAlternativeDistributionKeys, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterAccessType *[]string
	fieldsAnalyticsReportRequests *[]string
	fieldsAnalyticsReports *[]string
	limit *int32
	include *[]string
	limitReports *int32
}

// filter by attribute &#39;accessType&#39;
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) FilterAccessType(filterAccessType []string) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.filterAccessType = &filterAccessType
	return r
}

// the fields to include for returned resources of type analyticsReportRequests
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) FieldsAnalyticsReportRequests(fieldsAnalyticsReportRequests []string) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.fieldsAnalyticsReportRequests = &fieldsAnalyticsReportRequests
	return r
}

// the fields to include for returned resources of type analyticsReports
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) FieldsAnalyticsReports(fieldsAnalyticsReports []string) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.fieldsAnalyticsReports = &fieldsAnalyticsReports
	return r
}

// maximum resources per page
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) Include(include []string) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related reports returned (when they are included)
func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) LimitReports(limitReports int32) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	r.limitReports = &limitReports
	return r
}

func (r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) Execute() (*AnalyticsReportRequestsResponse, *http.Response, error) {
	return r.ApiService.AppsAnalyticsReportRequestsGetToManyRelatedExecute(r)
}

/*
AppsAnalyticsReportRequestsGetToManyRelated Method for AppsAnalyticsReportRequestsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAnalyticsReportRequestsGetToManyRelated(ctx context.Context, id string) ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest {
	return ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AnalyticsReportRequestsResponse
func (a *AppsAPIService) AppsAnalyticsReportRequestsGetToManyRelatedExecute(r ApiAppsAnalyticsReportRequestsGetToManyRelatedRequest) (*AnalyticsReportRequestsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AnalyticsReportRequestsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAnalyticsReportRequestsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/analyticsReportRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterAccessType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[accessType]", r.filterAccessType, "form", "csv")
	}
	if r.fieldsAnalyticsReportRequests != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[analyticsReportRequests]", r.fieldsAnalyticsReportRequests, "form", "csv")
	}
	if r.fieldsAnalyticsReports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[analyticsReports]", r.fieldsAnalyticsReports, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitReports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reports]", r.limitReports, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppAvailabilityGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAppAvailabilities *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	include *[]string
	limitAvailableTerritories *int32
}

// the fields to include for returned resources of type appAvailabilities
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) Include(include []string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

func (r ApiAppsAppAvailabilityGetToOneRelatedRequest) Execute() (*AppAvailabilityResponse, *http.Response, error) {
	return r.ApiService.AppsAppAvailabilityGetToOneRelatedExecute(r)
}

/*
AppsAppAvailabilityGetToOneRelated Method for AppsAppAvailabilityGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppAvailabilityGetToOneRelatedRequest

Deprecated
*/
func (a *AppsAPIService) AppsAppAvailabilityGetToOneRelated(ctx context.Context, id string) ApiAppsAppAvailabilityGetToOneRelatedRequest {
	return ApiAppsAppAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppAvailabilityResponse
// Deprecated
func (a *AppsAPIService) AppsAppAvailabilityGetToOneRelatedExecute(r ApiAppsAppAvailabilityGetToOneRelatedRequest) (*AppAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppAvailabilityV2GetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAppAvailabilities *[]string
	fieldsTerritoryAvailabilities *[]string
	include *[]string
	limitTerritoryAvailabilities *int32
}

// the fields to include for returned resources of type appAvailabilities
func (r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) FieldsAppAvailabilities(fieldsAppAvailabilities []string) ApiAppsAppAvailabilityV2GetToOneRelatedRequest {
	r.fieldsAppAvailabilities = &fieldsAppAvailabilities
	return r
}

// the fields to include for returned resources of type territoryAvailabilities
func (r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) FieldsTerritoryAvailabilities(fieldsTerritoryAvailabilities []string) ApiAppsAppAvailabilityV2GetToOneRelatedRequest {
	r.fieldsTerritoryAvailabilities = &fieldsTerritoryAvailabilities
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) Include(include []string) ApiAppsAppAvailabilityV2GetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related territoryAvailabilities returned (when they are included)
func (r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) LimitTerritoryAvailabilities(limitTerritoryAvailabilities int32) ApiAppsAppAvailabilityV2GetToOneRelatedRequest {
	r.limitTerritoryAvailabilities = &limitTerritoryAvailabilities
	return r
}

func (r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) Execute() (*AppAvailabilityV2Response, *http.Response, error) {
	return r.ApiService.AppsAppAvailabilityV2GetToOneRelatedExecute(r)
}

/*
AppsAppAvailabilityV2GetToOneRelated Method for AppsAppAvailabilityV2GetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppAvailabilityV2GetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsAppAvailabilityV2GetToOneRelated(ctx context.Context, id string) ApiAppsAppAvailabilityV2GetToOneRelatedRequest {
	return ApiAppsAppAvailabilityV2GetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppAvailabilityV2Response
func (a *AppsAPIService) AppsAppAvailabilityV2GetToOneRelatedExecute(r ApiAppsAppAvailabilityV2GetToOneRelatedRequest) (*AppAvailabilityV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppAvailabilityV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppAvailabilityV2GetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appAvailabilityV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appAvailabilities]", r.fieldsAppAvailabilities, "form", "csv")
	}
	if r.fieldsTerritoryAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territoryAvailabilities]", r.fieldsTerritoryAvailabilities, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitTerritoryAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[territoryAvailabilities]", r.limitTerritoryAvailabilities, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppClipsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterBundleId *[]string
	fieldsAppClips *[]string
	fieldsApps *[]string
	fieldsAppClipDefaultExperiences *[]string
	limit *int32
	include *[]string
	limitAppClipDefaultExperiences *int32
}

// filter by attribute &#39;bundleId&#39;
func (r ApiAppsAppClipsGetToManyRelatedRequest) FilterBundleId(filterBundleId []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r ApiAppsAppClipsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// maximum resources per page
func (r ApiAppsAppClipsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppClipsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppClipsGetToManyRelatedRequest) Include(include []string) ApiAppsAppClipsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related appClipDefaultExperiences returned (when they are included)
func (r ApiAppsAppClipsGetToManyRelatedRequest) LimitAppClipDefaultExperiences(limitAppClipDefaultExperiences int32) ApiAppsAppClipsGetToManyRelatedRequest {
	r.limitAppClipDefaultExperiences = &limitAppClipDefaultExperiences
	return r
}

func (r ApiAppsAppClipsGetToManyRelatedRequest) Execute() (*AppClipsResponse, *http.Response, error) {
	return r.ApiService.AppsAppClipsGetToManyRelatedExecute(r)
}

/*
AppsAppClipsGetToManyRelated Method for AppsAppClipsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppClipsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppClipsGetToManyRelated(ctx context.Context, id string) ApiAppsAppClipsGetToManyRelatedRequest {
	return ApiAppsAppClipsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppClipsResponse
func (a *AppsAPIService) AppsAppClipsGetToManyRelatedExecute(r ApiAppsAppClipsGetToManyRelatedRequest) (*AppClipsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppClipsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppClipsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appClips"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "form", "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClipDefaultExperiences]", r.limitAppClipDefaultExperiences, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppCustomProductPagesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterVisible *[]string
	fieldsAppCustomProductPages *[]string
	fieldsApps *[]string
	fieldsAppCustomProductPageVersions *[]string
	limit *int32
	include *[]string
	limitAppCustomProductPageVersions *int32
}

// filter by attribute &#39;visible&#39;
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FilterVisible(filterVisible []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.filterVisible = &filterVisible
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appCustomProductPageVersions
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) FieldsAppCustomProductPageVersions(fieldsAppCustomProductPageVersions []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.fieldsAppCustomProductPageVersions = &fieldsAppCustomProductPageVersions
	return r
}

// maximum resources per page
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Include(include []string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related appCustomProductPageVersions returned (when they are included)
func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) LimitAppCustomProductPageVersions(limitAppCustomProductPageVersions int32) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	r.limitAppCustomProductPageVersions = &limitAppCustomProductPageVersions
	return r
}

func (r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) Execute() (*AppCustomProductPagesResponse, *http.Response, error) {
	return r.ApiService.AppsAppCustomProductPagesGetToManyRelatedExecute(r)
}

/*
AppsAppCustomProductPagesGetToManyRelated Method for AppsAppCustomProductPagesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppCustomProductPagesGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppCustomProductPagesGetToManyRelated(ctx context.Context, id string) ApiAppsAppCustomProductPagesGetToManyRelatedRequest {
	return ApiAppsAppCustomProductPagesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCustomProductPagesResponse
func (a *AppsAPIService) AppsAppCustomProductPagesGetToManyRelatedExecute(r ApiAppsAppCustomProductPagesGetToManyRelatedRequest) (*AppCustomProductPagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCustomProductPagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppCustomProductPagesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appCustomProductPages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterVisible != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[visible]", r.filterVisible, "form", "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPageVersions]", r.fieldsAppCustomProductPageVersions, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppCustomProductPageVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPageVersions]", r.limitAppCustomProductPageVersions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterPlatform *[]string
	filterBuilds *[]string
	fieldsAppEncryptionDeclarations *[]string
	fieldsApps *[]string
	fieldsBuilds *[]string
	fieldsAppEncryptionDeclarationDocuments *[]string
	limit *int32
	include *[]string
	limitBuilds *int32
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by id(s) of related &#39;builds&#39;
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FilterBuilds(filterBuilds []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.filterBuilds = &filterBuilds
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarationDocuments
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) FieldsAppEncryptionDeclarationDocuments(fieldsAppEncryptionDeclarationDocuments []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.fieldsAppEncryptionDeclarationDocuments = &fieldsAppEncryptionDeclarationDocuments
	return r
}

// maximum resources per page
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Include(include []string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) LimitBuilds(limitBuilds int32) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	r.limitBuilds = &limitBuilds
	return r
}

func (r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) Execute() (*AppEncryptionDeclarationsResponse, *http.Response, error) {
	return r.ApiService.AppsAppEncryptionDeclarationsGetToManyRelatedExecute(r)
}

/*
AppsAppEncryptionDeclarationsGetToManyRelated Method for AppsAppEncryptionDeclarationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppEncryptionDeclarationsGetToManyRelated(ctx context.Context, id string) ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest {
	return ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEncryptionDeclarationsResponse
func (a *AppsAPIService) AppsAppEncryptionDeclarationsGetToManyRelatedExecute(r ApiAppsAppEncryptionDeclarationsGetToManyRelatedRequest) (*AppEncryptionDeclarationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEncryptionDeclarationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppEncryptionDeclarationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appEncryptionDeclarations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "form", "csv")
	}
	if r.filterBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[builds]", r.filterBuilds, "form", "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.fieldsAppEncryptionDeclarationDocuments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarationDocuments]", r.fieldsAppEncryptionDeclarationDocuments, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppEventsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterEventState *[]string
	filterId *[]string
	fieldsAppEvents *[]string
	fieldsAppEventLocalizations *[]string
	limit *int32
	include *[]string
	limitLocalizations *int32
}

// filter by attribute &#39;eventState&#39;
func (r ApiAppsAppEventsGetToManyRelatedRequest) FilterEventState(filterEventState []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.filterEventState = &filterEventState
	return r
}

// filter by id(s)
func (r ApiAppsAppEventsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type appEventLocalizations
func (r ApiAppsAppEventsGetToManyRelatedRequest) FieldsAppEventLocalizations(fieldsAppEventLocalizations []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.fieldsAppEventLocalizations = &fieldsAppEventLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsAppEventsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppEventsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppEventsGetToManyRelatedRequest) Include(include []string) ApiAppsAppEventsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related localizations returned (when they are included)
func (r ApiAppsAppEventsGetToManyRelatedRequest) LimitLocalizations(limitLocalizations int32) ApiAppsAppEventsGetToManyRelatedRequest {
	r.limitLocalizations = &limitLocalizations
	return r
}

func (r ApiAppsAppEventsGetToManyRelatedRequest) Execute() (*AppEventsResponse, *http.Response, error) {
	return r.ApiService.AppsAppEventsGetToManyRelatedExecute(r)
}

/*
AppsAppEventsGetToManyRelated Method for AppsAppEventsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppEventsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppEventsGetToManyRelated(ctx context.Context, id string) ApiAppsAppEventsGetToManyRelatedRequest {
	return ApiAppsAppEventsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppEventsResponse
func (a *AppsAPIService) AppsAppEventsGetToManyRelatedExecute(r ApiAppsAppEventsGetToManyRelatedRequest) (*AppEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppEventsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appEvents"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEventState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[eventState]", r.filterEventState, "form", "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "form", "csv")
	}
	if r.fieldsAppEventLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEventLocalizations]", r.fieldsAppEventLocalizations, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[localizations]", r.limitLocalizations, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppInfosGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAppInfos *[]string
	fieldsApps *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsAppCategories *[]string
	limit *int32
	include *[]string
	limitAppInfoLocalizations *int32
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r ApiAppsAppInfosGetToManyRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// maximum resources per page
func (r ApiAppsAppInfosGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppInfosGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppInfosGetToManyRelatedRequest) Include(include []string) ApiAppsAppInfosGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r ApiAppsAppInfosGetToManyRelatedRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) ApiAppsAppInfosGetToManyRelatedRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

func (r ApiAppsAppInfosGetToManyRelatedRequest) Execute() (*AppInfosResponse, *http.Response, error) {
	return r.ApiService.AppsAppInfosGetToManyRelatedExecute(r)
}

/*
AppsAppInfosGetToManyRelated Method for AppsAppInfosGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppInfosGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppInfosGetToManyRelated(ctx context.Context, id string) ApiAppsAppInfosGetToManyRelatedRequest {
	return ApiAppsAppInfosGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfosResponse
func (a *AppsAPIService) AppsAppInfosGetToManyRelatedExecute(r ApiAppsAppInfosGetToManyRelatedRequest) (*AppInfosResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfosResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppInfosGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "form", "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "form", "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterTerritory *[]string
	fieldsAppPricePoints *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type appPricePoints
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsAppPricePoints(fieldsAppPricePoints []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsAppPricePoints = &fieldsAppPricePoints
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Include(include []string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsAppPricePointsGetToManyRelatedRequest) Execute() (*AppPricePointsV3Response, *http.Response, error) {
	return r.ApiService.AppsAppPricePointsGetToManyRelatedExecute(r)
}

/*
AppsAppPricePointsGetToManyRelated Method for AppsAppPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppPricePointsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppPricePointsGetToManyRelated(ctx context.Context, id string) ApiAppsAppPricePointsGetToManyRelatedRequest {
	return ApiAppsAppPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPricePointsV3Response
func (a *AppsAPIService) AppsAppPricePointsGetToManyRelatedExecute(r ApiAppsAppPricePointsGetToManyRelatedRequest) (*AppPricePointsV3Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPricePointsV3Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsAppPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPricePoints]", r.fieldsAppPricePoints, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppPriceScheduleGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAppPriceSchedules *[]string
	fieldsApps *[]string
	fieldsTerritories *[]string
	fieldsAppPrices *[]string
	include *[]string
	limitManualPrices *int32
	limitAutomaticPrices *int32
}

// the fields to include for returned resources of type appPriceSchedules
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPriceSchedules(fieldsAppPriceSchedules []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPriceSchedules = &fieldsAppPriceSchedules
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type territories
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type appPrices
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) FieldsAppPrices(fieldsAppPrices []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.fieldsAppPrices = &fieldsAppPrices
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) Include(include []string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

func (r ApiAppsAppPriceScheduleGetToOneRelatedRequest) Execute() (*AppPriceScheduleResponse, *http.Response, error) {
	return r.ApiService.AppsAppPriceScheduleGetToOneRelatedExecute(r)
}

/*
AppsAppPriceScheduleGetToOneRelated Method for AppsAppPriceScheduleGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppPriceScheduleGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsAppPriceScheduleGetToOneRelated(ctx context.Context, id string) ApiAppsAppPriceScheduleGetToOneRelatedRequest {
	return ApiAppsAppPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPriceScheduleResponse
func (a *AppsAPIService) AppsAppPriceScheduleGetToOneRelatedExecute(r ApiAppsAppPriceScheduleGetToOneRelatedRequest) (*AppPriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPriceSchedules]", r.fieldsAppPriceSchedules, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.fieldsAppPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPrices]", r.fieldsAppPrices, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "form", "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterState *[]string
	fieldsAppStoreVersionExperiments *[]string
	fieldsApps *[]string
	fieldsAppStoreVersions *[]string
	fieldsAppStoreVersionExperimentTreatments *[]string
	limit *int32
	include *[]string
	limitControlVersions *int32
	limitAppStoreVersionExperimentTreatments *int32
}

// filter by attribute &#39;state&#39;
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FilterState(filterState []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type appStoreVersionExperimentTreatments
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) FieldsAppStoreVersionExperimentTreatments(fieldsAppStoreVersionExperimentTreatments []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperimentTreatments = &fieldsAppStoreVersionExperimentTreatments
	return r
}

// maximum resources per page
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Limit(limit int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Include(include []string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related controlVersions returned (when they are included)
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) LimitControlVersions(limitControlVersions int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limitControlVersions = &limitControlVersions
	return r
}

// maximum number of related appStoreVersionExperimentTreatments returned (when they are included)
func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) LimitAppStoreVersionExperimentTreatments(limitAppStoreVersionExperimentTreatments int32) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	r.limitAppStoreVersionExperimentTreatments = &limitAppStoreVersionExperimentTreatments
	return r
}

func (r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) Execute() (*AppStoreVersionExperimentsV2Response, *http.Response, error) {
	return r.ApiService.AppsAppStoreVersionExperimentsV2GetToManyRelatedExecute(r)
}

/*
AppsAppStoreVersionExperimentsV2GetToManyRelated Method for AppsAppStoreVersionExperimentsV2GetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppStoreVersionExperimentsV2GetToManyRelated(ctx context.Context, id string) ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest {
	return ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppStoreVersionExperimentsV2Response
func (a *AppsAPIService) AppsAppStoreVersionExperimentsV2GetToManyRelatedExecute(r ApiAppsAppStoreVersionExperimentsV2GetToManyRelatedRequest) (*AppStoreVersionExperimentsV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppStoreVersionExperimentsV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppStoreVersionExperimentsV2GetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersionExperimentsV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperimentTreatments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperimentTreatments]", r.fieldsAppStoreVersionExperimentTreatments, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitControlVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[controlVersions]", r.limitControlVersions, "form", "")
	}
	if r.limitAppStoreVersionExperimentTreatments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentTreatments]", r.limitAppStoreVersionExperimentTreatments, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsAppStoreVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterPlatform *[]string
	filterVersionString *[]string
	filterAppStoreState *[]string
	filterAppVersionState *[]string
	filterId *[]string
	fieldsAppStoreVersions *[]string
	fieldsApps *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppStoreVersionLocalizations *[]string
	fieldsBuilds *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsGameCenterAppVersions *[]string
	fieldsRoutingAppCoverages *[]string
	fieldsAppStoreReviewDetails *[]string
	fieldsAppStoreVersionSubmissions *[]string
	fieldsAppClipDefaultExperiences *[]string
	fieldsAppStoreVersionExperiments *[]string
	fieldsAlternativeDistributionPackages *[]string
	limit *int32
	include *[]string
	limitAppStoreVersionLocalizations *int32
	limitAppStoreVersionExperiments *int32
	limitAppStoreVersionExperimentsV2 *int32
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by attribute &#39;appStoreState&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterAppStoreState(filterAppStoreState []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterAppStoreState = &filterAppStoreState
	return r
}

// filter by attribute &#39;appVersionState&#39;
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterAppVersionState(filterAppVersionState []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterAppVersionState = &filterAppVersionState
	return r
}

// filter by id(s)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appStoreVersionLocalizations
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type appStoreVersionPhasedReleases
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type routingAppCoverages
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}

// the fields to include for returned resources of type appStoreReviewDetails
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}

// the fields to include for returned resources of type appStoreVersionSubmissions
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type alternativeDistributionPackages
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) FieldsAlternativeDistributionPackages(fieldsAlternativeDistributionPackages []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.fieldsAlternativeDistributionPackages = &fieldsAlternativeDistributionPackages
	return r
}

// maximum resources per page
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related appStoreVersionLocalizations returned (when they are included)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionLocalizations(limitAppStoreVersionLocalizations int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionLocalizations = &limitAppStoreVersionLocalizations
	return r
}

// maximum number of related appStoreVersionExperiments returned (when they are included)
// Deprecated
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionExperiments(limitAppStoreVersionExperiments int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionExperiments = &limitAppStoreVersionExperiments
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

func (r ApiAppsAppStoreVersionsGetToManyRelatedRequest) Execute() (*AppStoreVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsAppStoreVersionsGetToManyRelatedExecute(r)
}

/*
AppsAppStoreVersionsGetToManyRelated Method for AppsAppStoreVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsAppStoreVersionsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsAppStoreVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsAppStoreVersionsGetToManyRelatedRequest {
	return ApiAppsAppStoreVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppStoreVersionsResponse
func (a *AppsAPIService) AppsAppStoreVersionsGetToManyRelatedExecute(r ApiAppsAppStoreVersionsGetToManyRelatedRequest) (*AppStoreVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppStoreVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsAppStoreVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/appStoreVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "form", "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "form", "csv")
	}
	if r.filterAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreState]", r.filterAppStoreState, "form", "csv")
	}
	if r.filterAppVersionState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appVersionState]", r.filterAppVersionState, "form", "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "form", "csv")
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionLocalizations]", r.fieldsAppStoreVersionLocalizations, "form", "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionPhasedReleases]", r.fieldsAppStoreVersionPhasedReleases, "form", "csv")
	}
	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "form", "csv")
	}
	if r.fieldsRoutingAppCoverages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[routingAppCoverages]", r.fieldsRoutingAppCoverages, "form", "csv")
	}
	if r.fieldsAppStoreReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreReviewDetails]", r.fieldsAppStoreReviewDetails, "form", "csv")
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionSubmissions]", r.fieldsAppStoreVersionSubmissions, "form", "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "form", "csv")
	}
	if r.fieldsAlternativeDistributionPackages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[alternativeDistributionPackages]", r.fieldsAlternativeDistributionPackages, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionLocalizations]", r.limitAppStoreVersionLocalizations, "form", "")
	}
	if r.limitAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperiments]", r.limitAppStoreVersionExperiments, "form", "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsBetaAppLocalizations *[]string
	limit *int32
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) Execute() (*BetaAppLocalizationsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppLocalizationsGetToManyRelatedExecute(r)
}

/*
AppsBetaAppLocalizationsGetToManyRelated Method for AppsBetaAppLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsBetaAppLocalizationsGetToManyRelated(ctx context.Context, id string) ApiAppsBetaAppLocalizationsGetToManyRelatedRequest {
	return ApiAppsBetaAppLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaAppLocalizationsWithoutIncludesResponse
func (a *AppsAPIService) AppsBetaAppLocalizationsGetToManyRelatedExecute(r ApiAppsBetaAppLocalizationsGetToManyRelatedRequest) (*BetaAppLocalizationsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaAppLocalizationsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaAppLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaAppReviewDetailGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsBetaAppReviewDetails *[]string
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

func (r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) Execute() (*BetaAppReviewDetailWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaAppReviewDetailGetToOneRelatedExecute(r)
}

/*
AppsBetaAppReviewDetailGetToOneRelated Method for AppsBetaAppReviewDetailGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsBetaAppReviewDetailGetToOneRelated(ctx context.Context, id string) ApiAppsBetaAppReviewDetailGetToOneRelatedRequest {
	return ApiAppsBetaAppReviewDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaAppReviewDetailWithoutIncludesResponse
func (a *AppsAPIService) AppsBetaAppReviewDetailGetToOneRelatedExecute(r ApiAppsBetaAppReviewDetailGetToOneRelatedRequest) (*BetaAppReviewDetailWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaAppReviewDetailWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaAppReviewDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaAppReviewDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaGroupsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsBetaGroups *[]string
	limit *int32
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsBetaGroupsGetToManyRelatedRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// maximum resources per page
func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBetaGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaGroupsGetToManyRelatedRequest) Execute() (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaGroupsGetToManyRelatedExecute(r)
}

/*
AppsBetaGroupsGetToManyRelated Method for AppsBetaGroupsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaGroupsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsBetaGroupsGetToManyRelated(ctx context.Context, id string) ApiAppsBetaGroupsGetToManyRelatedRequest {
	return ApiAppsBetaGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaGroupsWithoutIncludesResponse
func (a *AppsAPIService) AppsBetaGroupsGetToManyRelatedExecute(r ApiAppsBetaGroupsGetToManyRelatedRequest) (*BetaGroupsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaGroupsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaLicenseAgreementGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsBetaLicenseAgreements *[]string
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

func (r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) Execute() (*BetaLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBetaLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsBetaLicenseAgreementGetToOneRelated Method for AppsBetaLicenseAgreementGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsBetaLicenseAgreementGetToOneRelated(ctx context.Context, id string) ApiAppsBetaLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsBetaLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BetaLicenseAgreementWithoutIncludesResponse
func (a *AppsAPIService) AppsBetaLicenseAgreementGetToOneRelatedExecute(r ApiAppsBetaLicenseAgreementGetToOneRelatedRequest) (*BetaLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BetaLicenseAgreementWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/betaLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaTesterUsagesGetMetricsRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	period *string
	groupBy *[]string
	filterBetaTesters *string
	limit *int32
}

// the duration of the reporting period
func (r ApiAppsBetaTesterUsagesGetMetricsRequest) Period(period string) ApiAppsBetaTesterUsagesGetMetricsRequest {
	r.period = &period
	return r
}

// the dimension by which to group the results
func (r ApiAppsBetaTesterUsagesGetMetricsRequest) GroupBy(groupBy []string) ApiAppsBetaTesterUsagesGetMetricsRequest {
	r.groupBy = &groupBy
	return r
}

// filter by &#39;betaTesters&#39; relationship dimension
func (r ApiAppsBetaTesterUsagesGetMetricsRequest) FilterBetaTesters(filterBetaTesters string) ApiAppsBetaTesterUsagesGetMetricsRequest {
	r.filterBetaTesters = &filterBetaTesters
	return r
}

// maximum number of groups to return per page
func (r ApiAppsBetaTesterUsagesGetMetricsRequest) Limit(limit int32) ApiAppsBetaTesterUsagesGetMetricsRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBetaTesterUsagesGetMetricsRequest) Execute() (*AppsBetaTesterUsagesV1MetricResponse, *http.Response, error) {
	return r.ApiService.AppsBetaTesterUsagesGetMetricsExecute(r)
}

/*
AppsBetaTesterUsagesGetMetrics Method for AppsBetaTesterUsagesGetMetrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaTesterUsagesGetMetricsRequest
*/
func (a *AppsAPIService) AppsBetaTesterUsagesGetMetrics(ctx context.Context, id string) ApiAppsBetaTesterUsagesGetMetricsRequest {
	return ApiAppsBetaTesterUsagesGetMetricsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppsBetaTesterUsagesV1MetricResponse
func (a *AppsAPIService) AppsBetaTesterUsagesGetMetricsExecute(r ApiAppsBetaTesterUsagesGetMetricsRequest) (*AppsBetaTesterUsagesV1MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppsBetaTesterUsagesV1MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaTesterUsagesGetMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/metrics/betaTesterUsages"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", r.groupBy, "form", "csv")
	}
	if r.filterBetaTesters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[betaTesters]", r.filterBetaTesters, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsBetaTestersDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	appBetaTestersLinkagesRequest *AppBetaTestersLinkagesRequest
}

// List of related linkages
func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) AppBetaTestersLinkagesRequest(appBetaTestersLinkagesRequest AppBetaTestersLinkagesRequest) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	r.appBetaTestersLinkagesRequest = &appBetaTestersLinkagesRequest
	return r
}

func (r ApiAppsBetaTestersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsBetaTestersDeleteToManyRelationshipExecute(r)
}

/*
AppsBetaTestersDeleteToManyRelationship Method for AppsBetaTestersDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBetaTestersDeleteToManyRelationshipRequest
*/
func (a *AppsAPIService) AppsBetaTestersDeleteToManyRelationship(ctx context.Context, id string) ApiAppsBetaTestersDeleteToManyRelationshipRequest {
	return ApiAppsBetaTestersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppsAPIService) AppsBetaTestersDeleteToManyRelationshipExecute(r ApiAppsBetaTestersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBetaTestersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/betaTesters"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appBetaTestersLinkagesRequest == nil {
		return nil, reportError("appBetaTestersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appBetaTestersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppsBuildsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsBuilds *[]string
	limit *int32
}

// the fields to include for returned resources of type builds
func (r ApiAppsBuildsGetToManyRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsBuildsGetToManyRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// maximum resources per page
func (r ApiAppsBuildsGetToManyRelatedRequest) Limit(limit int32) ApiAppsBuildsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsBuildsGetToManyRelatedRequest) Execute() (*BuildsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsBuildsGetToManyRelatedExecute(r)
}

/*
AppsBuildsGetToManyRelated Method for AppsBuildsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsBuildsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsBuildsGetToManyRelated(ctx context.Context, id string) ApiAppsBuildsGetToManyRelatedRequest {
	return ApiAppsBuildsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return BuildsWithoutIncludesResponse
func (a *AppsAPIService) AppsBuildsGetToManyRelatedExecute(r ApiAppsBuildsGetToManyRelatedRequest) (*BuildsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BuildsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsBuildsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsCiProductGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsCiProducts *[]string
	fieldsApps *[]string
	fieldsBundleIds *[]string
	fieldsScmRepositories *[]string
	include *[]string
	limitPrimaryRepositories *int32
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type bundleIds
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsBundleIds(fieldsBundleIds []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsBundleIds = &fieldsBundleIds
	return r
}

// the fields to include for returned resources of type scmRepositories
func (r ApiAppsCiProductGetToOneRelatedRequest) FieldsScmRepositories(fieldsScmRepositories []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.fieldsScmRepositories = &fieldsScmRepositories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsCiProductGetToOneRelatedRequest) Include(include []string) ApiAppsCiProductGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related primaryRepositories returned (when they are included)
func (r ApiAppsCiProductGetToOneRelatedRequest) LimitPrimaryRepositories(limitPrimaryRepositories int32) ApiAppsCiProductGetToOneRelatedRequest {
	r.limitPrimaryRepositories = &limitPrimaryRepositories
	return r
}

func (r ApiAppsCiProductGetToOneRelatedRequest) Execute() (*CiProductResponse, *http.Response, error) {
	return r.ApiService.AppsCiProductGetToOneRelatedExecute(r)
}

/*
AppsCiProductGetToOneRelated Method for AppsCiProductGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsCiProductGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsCiProductGetToOneRelated(ctx context.Context, id string) ApiAppsCiProductGetToOneRelatedRequest {
	return ApiAppsCiProductGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CiProductResponse
func (a *AppsAPIService) AppsCiProductGetToOneRelatedExecute(r ApiAppsCiProductGetToOneRelatedRequest) (*CiProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CiProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsCiProductGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/ciProduct"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsBundleIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[bundleIds]", r.fieldsBundleIds, "form", "csv")
	}
	if r.fieldsScmRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[scmRepositories]", r.fieldsScmRepositories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPrimaryRepositories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[primaryRepositories]", r.limitPrimaryRepositories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsCustomerReviewsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterTerritory *[]string
	filterRating *[]string
	existsPublishedResponse *bool
	sort *[]string
	fieldsCustomerReviews *[]string
	fieldsCustomerReviewResponses *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;territory&#39;
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// filter by attribute &#39;rating&#39;
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FilterRating(filterRating []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.filterRating = &filterRating
	return r
}

// filter by publishedResponse
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) ExistsPublishedResponse(existsPublishedResponse bool) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.existsPublishedResponse = &existsPublishedResponse
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Sort(sort []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type customerReviews
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviews(fieldsCustomerReviews []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviews = &fieldsCustomerReviews
	return r
}

// the fields to include for returned resources of type customerReviewResponses
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) FieldsCustomerReviewResponses(fieldsCustomerReviewResponses []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.fieldsCustomerReviewResponses = &fieldsCustomerReviewResponses
	return r
}

// maximum resources per page
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Limit(limit int32) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Include(include []string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppsCustomerReviewsGetToManyRelatedRequest) Execute() (*CustomerReviewsResponse, *http.Response, error) {
	return r.ApiService.AppsCustomerReviewsGetToManyRelatedExecute(r)
}

/*
AppsCustomerReviewsGetToManyRelated Method for AppsCustomerReviewsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsCustomerReviewsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsCustomerReviewsGetToManyRelated(ctx context.Context, id string) ApiAppsCustomerReviewsGetToManyRelatedRequest {
	return ApiAppsCustomerReviewsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return CustomerReviewsResponse
func (a *AppsAPIService) AppsCustomerReviewsGetToManyRelatedExecute(r ApiAppsCustomerReviewsGetToManyRelatedRequest) (*CustomerReviewsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CustomerReviewsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsCustomerReviewsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/customerReviews"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.filterRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[rating]", r.filterRating, "form", "csv")
	}
	if r.existsPublishedResponse != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[publishedResponse]", r.existsPublishedResponse, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsCustomerReviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviews]", r.fieldsCustomerReviews, "form", "csv")
	}
	if r.fieldsCustomerReviewResponses != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[customerReviewResponses]", r.fieldsCustomerReviewResponses, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsEndUserLicenseAgreements *[]string
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

func (r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) Execute() (*EndUserLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsEndUserLicenseAgreementGetToOneRelatedExecute(r)
}

/*
AppsEndUserLicenseAgreementGetToOneRelated Method for AppsEndUserLicenseAgreementGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsEndUserLicenseAgreementGetToOneRelated(ctx context.Context, id string) ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest {
	return ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EndUserLicenseAgreementWithoutIncludesResponse
func (a *AppsAPIService) AppsEndUserLicenseAgreementGetToOneRelatedExecute(r ApiAppsEndUserLicenseAgreementGetToOneRelatedRequest) (*EndUserLicenseAgreementWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndUserLicenseAgreementWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsEndUserLicenseAgreementGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/endUserLicenseAgreement"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGameCenterDetailGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsGameCenterDetails *[]string
	fieldsApps *[]string
	fieldsGameCenterAppVersions *[]string
	fieldsGameCenterGroups *[]string
	fieldsGameCenterLeaderboards *[]string
	fieldsGameCenterLeaderboardSets *[]string
	fieldsGameCenterAchievements *[]string
	fieldsGameCenterAchievementReleases *[]string
	fieldsGameCenterLeaderboardReleases *[]string
	fieldsGameCenterLeaderboardSetReleases *[]string
	include *[]string
	limitGameCenterAppVersions *int32
	limitGameCenterLeaderboards *int32
	limitGameCenterLeaderboardSets *int32
	limitGameCenterAchievements *int32
	limitAchievementReleases *int32
	limitLeaderboardReleases *int32
	limitLeaderboardSetReleases *int32
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type gameCenterGroups
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterGroups(fieldsGameCenterGroups []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterGroups = &fieldsGameCenterGroups
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboards
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboards(fieldsGameCenterLeaderboards []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboards = &fieldsGameCenterLeaderboards
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardSets
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardSets(fieldsGameCenterLeaderboardSets []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardSets = &fieldsGameCenterLeaderboardSets
	return r
}

// the fields to include for returned resources of type gameCenterAchievements
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAchievements(fieldsGameCenterAchievements []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAchievements = &fieldsGameCenterAchievements
	return r
}

// the fields to include for returned resources of type gameCenterAchievementReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterAchievementReleases(fieldsGameCenterAchievementReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterAchievementReleases = &fieldsGameCenterAchievementReleases
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardReleases(fieldsGameCenterLeaderboardReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardReleases = &fieldsGameCenterLeaderboardReleases
	return r
}

// the fields to include for returned resources of type gameCenterLeaderboardSetReleases
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) FieldsGameCenterLeaderboardSetReleases(fieldsGameCenterLeaderboardSetReleases []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.fieldsGameCenterLeaderboardSetReleases = &fieldsGameCenterLeaderboardSetReleases
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) Include(include []string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related gameCenterAppVersions returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterAppVersions(limitGameCenterAppVersions int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterAppVersions = &limitGameCenterAppVersions
	return r
}

// maximum number of related gameCenterLeaderboards returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterLeaderboards(limitGameCenterLeaderboards int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterLeaderboards = &limitGameCenterLeaderboards
	return r
}

// maximum number of related gameCenterLeaderboardSets returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterLeaderboardSets(limitGameCenterLeaderboardSets int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterLeaderboardSets = &limitGameCenterLeaderboardSets
	return r
}

// maximum number of related gameCenterAchievements returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitGameCenterAchievements(limitGameCenterAchievements int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitGameCenterAchievements = &limitGameCenterAchievements
	return r
}

// maximum number of related achievementReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitAchievementReleases(limitAchievementReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitAchievementReleases = &limitAchievementReleases
	return r
}

// maximum number of related leaderboardReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitLeaderboardReleases(limitLeaderboardReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitLeaderboardReleases = &limitLeaderboardReleases
	return r
}

// maximum number of related leaderboardSetReleases returned (when they are included)
func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) LimitLeaderboardSetReleases(limitLeaderboardSetReleases int32) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	r.limitLeaderboardSetReleases = &limitLeaderboardSetReleases
	return r
}

func (r ApiAppsGameCenterDetailGetToOneRelatedRequest) Execute() (*GameCenterDetailResponse, *http.Response, error) {
	return r.ApiService.AppsGameCenterDetailGetToOneRelatedExecute(r)
}

/*
AppsGameCenterDetailGetToOneRelated Method for AppsGameCenterDetailGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsGameCenterDetailGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsGameCenterDetailGetToOneRelated(ctx context.Context, id string) ApiAppsGameCenterDetailGetToOneRelatedRequest {
	return ApiAppsGameCenterDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterDetailResponse
func (a *AppsAPIService) AppsGameCenterDetailGetToOneRelatedExecute(r ApiAppsGameCenterDetailGetToOneRelatedRequest) (*GameCenterDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsGameCenterDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "form", "csv")
	}
	if r.fieldsGameCenterGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterGroups]", r.fieldsGameCenterGroups, "form", "csv")
	}
	if r.fieldsGameCenterLeaderboards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboards]", r.fieldsGameCenterLeaderboards, "form", "csv")
	}
	if r.fieldsGameCenterLeaderboardSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardSets]", r.fieldsGameCenterLeaderboardSets, "form", "csv")
	}
	if r.fieldsGameCenterAchievements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAchievements]", r.fieldsGameCenterAchievements, "form", "csv")
	}
	if r.fieldsGameCenterAchievementReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAchievementReleases]", r.fieldsGameCenterAchievementReleases, "form", "csv")
	}
	if r.fieldsGameCenterLeaderboardReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardReleases]", r.fieldsGameCenterLeaderboardReleases, "form", "csv")
	}
	if r.fieldsGameCenterLeaderboardSetReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterLeaderboardSetReleases]", r.fieldsGameCenterLeaderboardSetReleases, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterAppVersions]", r.limitGameCenterAppVersions, "form", "")
	}
	if r.limitGameCenterLeaderboards != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterLeaderboards]", r.limitGameCenterLeaderboards, "form", "")
	}
	if r.limitGameCenterLeaderboardSets != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterLeaderboardSets]", r.limitGameCenterLeaderboardSets, "form", "")
	}
	if r.limitGameCenterAchievements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterAchievements]", r.limitGameCenterAchievements, "form", "")
	}
	if r.limitAchievementReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[achievementReleases]", r.limitAchievementReleases, "form", "")
	}
	if r.limitLeaderboardReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[leaderboardReleases]", r.limitLeaderboardReleases, "form", "")
	}
	if r.limitLeaderboardSetReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[leaderboardSetReleases]", r.limitLeaderboardSetReleases, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterPlatform *[]string
	filterVersionString *[]string
	filterId *[]string
	sort *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
	limitCompatibleVersions *int32
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;versionString&#39;
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterVersionString(filterVersionString []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterVersionString = &filterVersionString
	return r
}

// filter by id(s)
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FilterId(filterId []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.filterId = &filterId
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Sort(sort []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Include(include []string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related compatibleVersions returned (when they are included)
// Deprecated
func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) LimitCompatibleVersions(limitCompatibleVersions int32) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	r.limitCompatibleVersions = &limitCompatibleVersions
	return r
}

func (r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) Execute() (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	return r.ApiService.AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r)
}

/*
AppsGameCenterEnabledVersionsGetToManyRelated Method for AppsGameCenterEnabledVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest

Deprecated
*/
func (a *AppsAPIService) AppsGameCenterEnabledVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest {
	return ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterEnabledVersionsResponse
// Deprecated
func (a *AppsAPIService) AppsGameCenterEnabledVersionsGetToManyRelatedExecute(r ApiAppsGameCenterEnabledVersionsGetToManyRelatedRequest) (*GameCenterEnabledVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterEnabledVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsGameCenterEnabledVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/gameCenterEnabledVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "form", "csv")
	}
	if r.filterVersionString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[versionString]", r.filterVersionString, "form", "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitCompatibleVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[compatibleVersions]", r.limitCompatibleVersions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetCollectionRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	filterName *[]string
	filterBundleId *[]string
	filterSku *[]string
	filterAppStoreVersionsAppStoreState *[]string
	filterAppStoreVersionsPlatform *[]string
	filterAppStoreVersionsAppVersionState *[]string
	filterReviewSubmissionsState *[]string
	filterReviewSubmissionsPlatform *[]string
	filterAppStoreVersions *[]string
	filterId *[]string
	existsGameCenterEnabledVersions *bool
	sort *[]string
	fieldsApps *[]string
	fieldsAppEncryptionDeclarations *[]string
	fieldsCiProducts *[]string
	fieldsBetaGroups *[]string
	fieldsAppStoreVersions *[]string
	fieldsPreReleaseVersions *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsBuilds *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsAppInfos *[]string
	fieldsAppClips *[]string
	fieldsEndUserLicenseAgreements *[]string
	fieldsAppPreOrders *[]string
	fieldsInAppPurchases *[]string
	fieldsSubscriptionGroups *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsAppCustomProductPages *[]string
	fieldsPromotedPurchases *[]string
	fieldsAppEvents *[]string
	fieldsReviewSubmissions *[]string
	fieldsSubscriptionGracePeriods *[]string
	fieldsGameCenterDetails *[]string
	fieldsAppStoreVersionExperiments *[]string
	limit *int32
	include *[]string
	limitAppClips *int32
	limitAppCustomProductPages *int32
	limitAppEncryptionDeclarations *int32
	limitAppEvents *int32
	limitAppInfos *int32
	limitAppStoreVersionExperimentsV2 *int32
	limitAppStoreVersions *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitInAppPurchasesV2 *int32
	limitPreReleaseVersions *int32
	limitPromotedPurchases *int32
	limitReviewSubmissions *int32
	limitSubscriptionGroups *int32
}

// filter by attribute &#39;name&#39;
func (r ApiAppsGetCollectionRequest) FilterName(filterName []string) ApiAppsGetCollectionRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;bundleId&#39;
func (r ApiAppsGetCollectionRequest) FilterBundleId(filterBundleId []string) ApiAppsGetCollectionRequest {
	r.filterBundleId = &filterBundleId
	return r
}

// filter by attribute &#39;sku&#39;
func (r ApiAppsGetCollectionRequest) FilterSku(filterSku []string) ApiAppsGetCollectionRequest {
	r.filterSku = &filterSku
	return r
}

// filter by attribute &#39;appStoreVersions.appStoreState&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsAppStoreState(filterAppStoreVersionsAppStoreState []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsAppStoreState = &filterAppStoreVersionsAppStoreState
	return r
}

// filter by attribute &#39;appStoreVersions.platform&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsPlatform(filterAppStoreVersionsPlatform []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsPlatform = &filterAppStoreVersionsPlatform
	return r
}

// filter by attribute &#39;appStoreVersions.appVersionState&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersionsAppVersionState(filterAppStoreVersionsAppVersionState []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersionsAppVersionState = &filterAppStoreVersionsAppVersionState
	return r
}

// filter by attribute &#39;reviewSubmissions.state&#39;
func (r ApiAppsGetCollectionRequest) FilterReviewSubmissionsState(filterReviewSubmissionsState []string) ApiAppsGetCollectionRequest {
	r.filterReviewSubmissionsState = &filterReviewSubmissionsState
	return r
}

// filter by attribute &#39;reviewSubmissions.platform&#39;
func (r ApiAppsGetCollectionRequest) FilterReviewSubmissionsPlatform(filterReviewSubmissionsPlatform []string) ApiAppsGetCollectionRequest {
	r.filterReviewSubmissionsPlatform = &filterReviewSubmissionsPlatform
	return r
}

// filter by id(s) of related &#39;appStoreVersions&#39;
func (r ApiAppsGetCollectionRequest) FilterAppStoreVersions(filterAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.filterAppStoreVersions = &filterAppStoreVersions
	return r
}

// filter by id(s)
func (r ApiAppsGetCollectionRequest) FilterId(filterId []string) ApiAppsGetCollectionRequest {
	r.filterId = &filterId
	return r
}

// filter by existence or non-existence of related &#39;gameCenterEnabledVersions&#39;
// Deprecated
func (r ApiAppsGetCollectionRequest) ExistsGameCenterEnabledVersions(existsGameCenterEnabledVersions bool) ApiAppsGetCollectionRequest {
	r.existsGameCenterEnabledVersions = &existsGameCenterEnabledVersions
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsGetCollectionRequest) Sort(sort []string) ApiAppsGetCollectionRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsGetCollectionRequest) FieldsApps(fieldsApps []string) ApiAppsGetCollectionRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsGetCollectionRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsGetCollectionRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsGetCollectionRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsGetCollectionRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsGetCollectionRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsGetCollectionRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsGetCollectionRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsGetCollectionRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsGetCollectionRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetCollectionRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsGetCollectionRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsGetCollectionRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetCollectionRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsGetCollectionRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetCollectionRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsGetCollectionRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsGetCollectionRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsGetCollectionRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetCollectionRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appPreOrders
// Deprecated
func (r ApiAppsGetCollectionRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetCollectionRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsGetCollectionRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetCollectionRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsGetCollectionRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
// Deprecated
func (r ApiAppsGetCollectionRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetCollectionRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsGetCollectionRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsGetCollectionRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsGetCollectionRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsGetCollectionRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsGetCollectionRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsGetCollectionRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsGetCollectionRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsGetCollectionRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsGetCollectionRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsGetCollectionRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGetCollectionRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGetCollectionRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsGetCollectionRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsGetCollectionRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// maximum resources per page
func (r ApiAppsGetCollectionRequest) Limit(limit int32) ApiAppsGetCollectionRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGetCollectionRequest) Include(include []string) ApiAppsGetCollectionRequest {
	r.include = &include
	return r
}

// maximum number of related appClips returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppClips(limitAppClips int32) ApiAppsGetCollectionRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) ApiAppsGetCollectionRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEncryptionDeclarations returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppEncryptionDeclarations(limitAppEncryptionDeclarations int32) ApiAppsGetCollectionRequest {
	r.limitAppEncryptionDeclarations = &limitAppEncryptionDeclarations
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppEvents(limitAppEvents int32) ApiAppsGetCollectionRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetCollectionRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsGetCollectionRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetCollectionRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetCollectionRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetCollectionRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitBuilds(limitBuilds int32) ApiAppsGetCollectionRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
// Deprecated
func (r ApiAppsGetCollectionRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetCollectionRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
// Deprecated
func (r ApiAppsGetCollectionRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetCollectionRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) ApiAppsGetCollectionRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetCollectionRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitPromotedPurchases(limitPromotedPurchases int32) ApiAppsGetCollectionRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitReviewSubmissions(limitReviewSubmissions int32) ApiAppsGetCollectionRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r ApiAppsGetCollectionRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) ApiAppsGetCollectionRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r ApiAppsGetCollectionRequest) Execute() (*AppsResponse, *http.Response, error) {
	return r.ApiService.AppsGetCollectionExecute(r)
}

/*
AppsGetCollection Method for AppsGetCollection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAppsGetCollectionRequest
*/
func (a *AppsAPIService) AppsGetCollection(ctx context.Context) ApiAppsGetCollectionRequest {
	return ApiAppsGetCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AppsResponse
func (a *AppsAPIService) AppsGetCollectionExecute(r ApiAppsGetCollectionRequest) (*AppsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsGetCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "csv")
	}
	if r.filterBundleId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[bundleId]", r.filterBundleId, "form", "csv")
	}
	if r.filterSku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[sku]", r.filterSku, "form", "csv")
	}
	if r.filterAppStoreVersionsAppStoreState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.appStoreState]", r.filterAppStoreVersionsAppStoreState, "form", "csv")
	}
	if r.filterAppStoreVersionsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.platform]", r.filterAppStoreVersionsPlatform, "form", "csv")
	}
	if r.filterAppStoreVersionsAppVersionState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions.appVersionState]", r.filterAppStoreVersionsAppVersionState, "form", "csv")
	}
	if r.filterReviewSubmissionsState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[reviewSubmissions.state]", r.filterReviewSubmissionsState, "form", "csv")
	}
	if r.filterReviewSubmissionsPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[reviewSubmissions.platform]", r.filterReviewSubmissionsPlatform, "form", "csv")
	}
	if r.filterAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[appStoreVersions]", r.filterAppStoreVersions, "form", "csv")
	}
	if r.filterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[id]", r.filterId, "form", "csv")
	}
	if r.existsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exists[gameCenterEnabledVersions]", r.existsGameCenterEnabledVersions, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "form", "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "form", "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "form", "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "form", "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "form", "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "form", "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "form", "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "form", "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "form", "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "form", "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "form", "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "form", "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "form", "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "form", "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "form", "csv")
	}
	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "form", "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "form", "")
	}
	if r.limitAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEncryptionDeclarations]", r.limitAppEncryptionDeclarations, "form", "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "form", "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "form", "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "form", "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "form", "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "form", "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "form", "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "form", "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "form", "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "form", "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "form", "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "form", "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "form", "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "form", "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsGetInstanceRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsApps *[]string
	fieldsAppEncryptionDeclarations *[]string
	fieldsCiProducts *[]string
	fieldsBetaGroups *[]string
	fieldsAppStoreVersions *[]string
	fieldsPreReleaseVersions *[]string
	fieldsBetaAppLocalizations *[]string
	fieldsBuilds *[]string
	fieldsBetaLicenseAgreements *[]string
	fieldsBetaAppReviewDetails *[]string
	fieldsAppInfos *[]string
	fieldsAppClips *[]string
	fieldsEndUserLicenseAgreements *[]string
	fieldsAppPreOrders *[]string
	fieldsInAppPurchases *[]string
	fieldsSubscriptionGroups *[]string
	fieldsGameCenterEnabledVersions *[]string
	fieldsAppCustomProductPages *[]string
	fieldsPromotedPurchases *[]string
	fieldsAppEvents *[]string
	fieldsReviewSubmissions *[]string
	fieldsSubscriptionGracePeriods *[]string
	fieldsGameCenterDetails *[]string
	fieldsAppStoreVersionExperiments *[]string
	include *[]string
	limitAppClips *int32
	limitAppCustomProductPages *int32
	limitAppEncryptionDeclarations *int32
	limitAppEvents *int32
	limitAppInfos *int32
	limitAppStoreVersionExperimentsV2 *int32
	limitAppStoreVersions *int32
	limitBetaAppLocalizations *int32
	limitBetaGroups *int32
	limitBuilds *int32
	limitGameCenterEnabledVersions *int32
	limitInAppPurchases *int32
	limitInAppPurchasesV2 *int32
	limitPreReleaseVersions *int32
	limitPromotedPurchases *int32
	limitReviewSubmissions *int32
	limitSubscriptionGroups *int32
}

// the fields to include for returned resources of type apps
func (r ApiAppsGetInstanceRequest) FieldsApps(fieldsApps []string) ApiAppsGetInstanceRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type appEncryptionDeclarations
func (r ApiAppsGetInstanceRequest) FieldsAppEncryptionDeclarations(fieldsAppEncryptionDeclarations []string) ApiAppsGetInstanceRequest {
	r.fieldsAppEncryptionDeclarations = &fieldsAppEncryptionDeclarations
	return r
}

// the fields to include for returned resources of type ciProducts
func (r ApiAppsGetInstanceRequest) FieldsCiProducts(fieldsCiProducts []string) ApiAppsGetInstanceRequest {
	r.fieldsCiProducts = &fieldsCiProducts
	return r
}

// the fields to include for returned resources of type betaGroups
func (r ApiAppsGetInstanceRequest) FieldsBetaGroups(fieldsBetaGroups []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaGroups = &fieldsBetaGroups
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsGetInstanceRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// the fields to include for returned resources of type betaAppLocalizations
func (r ApiAppsGetInstanceRequest) FieldsBetaAppLocalizations(fieldsBetaAppLocalizations []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppLocalizations = &fieldsBetaAppLocalizations
	return r
}

// the fields to include for returned resources of type builds
func (r ApiAppsGetInstanceRequest) FieldsBuilds(fieldsBuilds []string) ApiAppsGetInstanceRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type betaLicenseAgreements
func (r ApiAppsGetInstanceRequest) FieldsBetaLicenseAgreements(fieldsBetaLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaLicenseAgreements = &fieldsBetaLicenseAgreements
	return r
}

// the fields to include for returned resources of type betaAppReviewDetails
func (r ApiAppsGetInstanceRequest) FieldsBetaAppReviewDetails(fieldsBetaAppReviewDetails []string) ApiAppsGetInstanceRequest {
	r.fieldsBetaAppReviewDetails = &fieldsBetaAppReviewDetails
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppsGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppsGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type appClips
func (r ApiAppsGetInstanceRequest) FieldsAppClips(fieldsAppClips []string) ApiAppsGetInstanceRequest {
	r.fieldsAppClips = &fieldsAppClips
	return r
}

// the fields to include for returned resources of type endUserLicenseAgreements
func (r ApiAppsGetInstanceRequest) FieldsEndUserLicenseAgreements(fieldsEndUserLicenseAgreements []string) ApiAppsGetInstanceRequest {
	r.fieldsEndUserLicenseAgreements = &fieldsEndUserLicenseAgreements
	return r
}

// the fields to include for returned resources of type appPreOrders
// Deprecated
func (r ApiAppsGetInstanceRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsGetInstanceRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsGetInstanceRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type gameCenterEnabledVersions
// Deprecated
func (r ApiAppsGetInstanceRequest) FieldsGameCenterEnabledVersions(fieldsGameCenterEnabledVersions []string) ApiAppsGetInstanceRequest {
	r.fieldsGameCenterEnabledVersions = &fieldsGameCenterEnabledVersions
	return r
}

// the fields to include for returned resources of type appCustomProductPages
func (r ApiAppsGetInstanceRequest) FieldsAppCustomProductPages(fieldsAppCustomProductPages []string) ApiAppsGetInstanceRequest {
	r.fieldsAppCustomProductPages = &fieldsAppCustomProductPages
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type appEvents
func (r ApiAppsGetInstanceRequest) FieldsAppEvents(fieldsAppEvents []string) ApiAppsGetInstanceRequest {
	r.fieldsAppEvents = &fieldsAppEvents
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsGetInstanceRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsGetInstanceRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsGetInstanceRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsGetInstanceRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

// the fields to include for returned resources of type gameCenterDetails
func (r ApiAppsGetInstanceRequest) FieldsGameCenterDetails(fieldsGameCenterDetails []string) ApiAppsGetInstanceRequest {
	r.fieldsGameCenterDetails = &fieldsGameCenterDetails
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiAppsGetInstanceRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiAppsGetInstanceRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsGetInstanceRequest) Include(include []string) ApiAppsGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related appClips returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppClips(limitAppClips int32) ApiAppsGetInstanceRequest {
	r.limitAppClips = &limitAppClips
	return r
}

// maximum number of related appCustomProductPages returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppCustomProductPages(limitAppCustomProductPages int32) ApiAppsGetInstanceRequest {
	r.limitAppCustomProductPages = &limitAppCustomProductPages
	return r
}

// maximum number of related appEncryptionDeclarations returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppEncryptionDeclarations(limitAppEncryptionDeclarations int32) ApiAppsGetInstanceRequest {
	r.limitAppEncryptionDeclarations = &limitAppEncryptionDeclarations
	return r
}

// maximum number of related appEvents returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppEvents(limitAppEvents int32) ApiAppsGetInstanceRequest {
	r.limitAppEvents = &limitAppEvents
	return r
}

// maximum number of related appInfos returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppInfos(limitAppInfos int32) ApiAppsGetInstanceRequest {
	r.limitAppInfos = &limitAppInfos
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiAppsGetInstanceRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

// maximum number of related appStoreVersions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitAppStoreVersions(limitAppStoreVersions int32) ApiAppsGetInstanceRequest {
	r.limitAppStoreVersions = &limitAppStoreVersions
	return r
}

// maximum number of related betaAppLocalizations returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBetaAppLocalizations(limitBetaAppLocalizations int32) ApiAppsGetInstanceRequest {
	r.limitBetaAppLocalizations = &limitBetaAppLocalizations
	return r
}

// maximum number of related betaGroups returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBetaGroups(limitBetaGroups int32) ApiAppsGetInstanceRequest {
	r.limitBetaGroups = &limitBetaGroups
	return r
}

// maximum number of related builds returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitBuilds(limitBuilds int32) ApiAppsGetInstanceRequest {
	r.limitBuilds = &limitBuilds
	return r
}

// maximum number of related gameCenterEnabledVersions returned (when they are included)
// Deprecated
func (r ApiAppsGetInstanceRequest) LimitGameCenterEnabledVersions(limitGameCenterEnabledVersions int32) ApiAppsGetInstanceRequest {
	r.limitGameCenterEnabledVersions = &limitGameCenterEnabledVersions
	return r
}

// maximum number of related inAppPurchases returned (when they are included)
// Deprecated
func (r ApiAppsGetInstanceRequest) LimitInAppPurchases(limitInAppPurchases int32) ApiAppsGetInstanceRequest {
	r.limitInAppPurchases = &limitInAppPurchases
	return r
}

// maximum number of related inAppPurchasesV2 returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitInAppPurchasesV2(limitInAppPurchasesV2 int32) ApiAppsGetInstanceRequest {
	r.limitInAppPurchasesV2 = &limitInAppPurchasesV2
	return r
}

// maximum number of related preReleaseVersions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitPreReleaseVersions(limitPreReleaseVersions int32) ApiAppsGetInstanceRequest {
	r.limitPreReleaseVersions = &limitPreReleaseVersions
	return r
}

// maximum number of related promotedPurchases returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitPromotedPurchases(limitPromotedPurchases int32) ApiAppsGetInstanceRequest {
	r.limitPromotedPurchases = &limitPromotedPurchases
	return r
}

// maximum number of related reviewSubmissions returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitReviewSubmissions(limitReviewSubmissions int32) ApiAppsGetInstanceRequest {
	r.limitReviewSubmissions = &limitReviewSubmissions
	return r
}

// maximum number of related subscriptionGroups returned (when they are included)
func (r ApiAppsGetInstanceRequest) LimitSubscriptionGroups(limitSubscriptionGroups int32) ApiAppsGetInstanceRequest {
	r.limitSubscriptionGroups = &limitSubscriptionGroups
	return r
}

func (r ApiAppsGetInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsGetInstanceExecute(r)
}

/*
AppsGetInstance Method for AppsGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsGetInstanceRequest
*/
func (a *AppsAPIService) AppsGetInstance(ctx context.Context, id string) ApiAppsGetInstanceRequest {
	return ApiAppsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppResponse
func (a *AppsAPIService) AppsGetInstanceExecute(r ApiAppsGetInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEncryptionDeclarations]", r.fieldsAppEncryptionDeclarations, "form", "csv")
	}
	if r.fieldsCiProducts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ciProducts]", r.fieldsCiProducts, "form", "csv")
	}
	if r.fieldsBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaGroups]", r.fieldsBetaGroups, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "form", "csv")
	}
	if r.fieldsBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppLocalizations]", r.fieldsBetaAppLocalizations, "form", "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.fieldsBetaLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaLicenseAgreements]", r.fieldsBetaLicenseAgreements, "form", "csv")
	}
	if r.fieldsBetaAppReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[betaAppReviewDetails]", r.fieldsBetaAppReviewDetails, "form", "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "form", "csv")
	}
	if r.fieldsAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClips]", r.fieldsAppClips, "form", "csv")
	}
	if r.fieldsEndUserLicenseAgreements != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[endUserLicenseAgreements]", r.fieldsEndUserLicenseAgreements, "form", "csv")
	}
	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "form", "csv")
	}
	if r.fieldsGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterEnabledVersions]", r.fieldsGameCenterEnabledVersions, "form", "csv")
	}
	if r.fieldsAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCustomProductPages]", r.fieldsAppCustomProductPages, "form", "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appEvents]", r.fieldsAppEvents, "form", "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "form", "csv")
	}
	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "form", "csv")
	}
	if r.fieldsGameCenterDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterDetails]", r.fieldsGameCenterDetails, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppClips != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appClips]", r.limitAppClips, "form", "")
	}
	if r.limitAppCustomProductPages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appCustomProductPages]", r.limitAppCustomProductPages, "form", "")
	}
	if r.limitAppEncryptionDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEncryptionDeclarations]", r.limitAppEncryptionDeclarations, "form", "")
	}
	if r.limitAppEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appEvents]", r.limitAppEvents, "form", "")
	}
	if r.limitAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfos]", r.limitAppInfos, "form", "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "form", "")
	}
	if r.limitAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersions]", r.limitAppStoreVersions, "form", "")
	}
	if r.limitBetaAppLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaAppLocalizations]", r.limitBetaAppLocalizations, "form", "")
	}
	if r.limitBetaGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[betaGroups]", r.limitBetaGroups, "form", "")
	}
	if r.limitBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[builds]", r.limitBuilds, "form", "")
	}
	if r.limitGameCenterEnabledVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[gameCenterEnabledVersions]", r.limitGameCenterEnabledVersions, "form", "")
	}
	if r.limitInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchases]", r.limitInAppPurchases, "form", "")
	}
	if r.limitInAppPurchasesV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchasesV2]", r.limitInAppPurchasesV2, "form", "")
	}
	if r.limitPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[preReleaseVersions]", r.limitPreReleaseVersions, "form", "")
	}
	if r.limitPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotedPurchases]", r.limitPromotedPurchases, "form", "")
	}
	if r.limitReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[reviewSubmissions]", r.limitReviewSubmissions, "form", "")
	}
	if r.limitSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroups]", r.limitSubscriptionGroups, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsInAppPurchasesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterInAppPurchaseType *[]string
	filterCanBeSubmitted *[]string
	sort *[]string
	fieldsInAppPurchases *[]string
	fieldsApps *[]string
	limit *int32
	include *[]string
	limitApps *int32
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// filter by canBeSubmitted
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FilterCanBeSubmitted(filterCanBeSubmitted []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.filterCanBeSubmitted = &filterCanBeSubmitted
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Sort(sort []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// maximum resources per page
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Limit(limit int32) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Include(include []string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) LimitApps(limitApps int32) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	r.limitApps = &limitApps
	return r
}

func (r ApiAppsInAppPurchasesGetToManyRelatedRequest) Execute() (*InAppPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesGetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesGetToManyRelated Method for AppsInAppPurchasesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsInAppPurchasesGetToManyRelatedRequest

Deprecated
*/
func (a *AppsAPIService) AppsInAppPurchasesGetToManyRelated(ctx context.Context, id string) ApiAppsInAppPurchasesGetToManyRelatedRequest {
	return ApiAppsInAppPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasesResponse
// Deprecated
func (a *AppsAPIService) AppsInAppPurchasesGetToManyRelatedExecute(r ApiAppsInAppPurchasesGetToManyRelatedRequest) (*InAppPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsInAppPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "form", "csv")
	}
	if r.filterCanBeSubmitted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[canBeSubmitted]", r.filterCanBeSubmitted, "form", "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsInAppPurchasesV2GetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterProductId *[]string
	filterName *[]string
	filterState *[]string
	filterInAppPurchaseType *[]string
	sort *[]string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchaseContents *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchaseAvailabilities *[]string
	fieldsInAppPurchaseImages *[]string
	limit *int32
	include *[]string
	limitInAppPurchaseLocalizations *int32
	limitImages *int32
}

// filter by attribute &#39;productId&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterProductId(filterProductId []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterProductId = &filterProductId
	return r
}

// filter by attribute &#39;name&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterName(filterName []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterName = &filterName
	return r
}

// filter by attribute &#39;state&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterState(filterState []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// filter by attribute &#39;inAppPurchaseType&#39;
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FilterInAppPurchaseType(filterInAppPurchaseType []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.filterInAppPurchaseType = &filterInAppPurchaseType
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Sort(sort []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseAvailabilities
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseAvailabilities(fieldsInAppPurchaseAvailabilities []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseAvailabilities = &fieldsInAppPurchaseAvailabilities
	return r
}

// the fields to include for returned resources of type inAppPurchaseImages
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) FieldsInAppPurchaseImages(fieldsInAppPurchaseImages []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.fieldsInAppPurchaseImages = &fieldsInAppPurchaseImages
	return r
}

// maximum resources per page
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Limit(limit int32) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Include(include []string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// maximum number of related images returned (when they are included)
func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) LimitImages(limitImages int32) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	r.limitImages = &limitImages
	return r
}

func (r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) Execute() (*InAppPurchasesV2Response, *http.Response, error) {
	return r.ApiService.AppsInAppPurchasesV2GetToManyRelatedExecute(r)
}

/*
AppsInAppPurchasesV2GetToManyRelated Method for AppsInAppPurchasesV2GetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsInAppPurchasesV2GetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsInAppPurchasesV2GetToManyRelated(ctx context.Context, id string) ApiAppsInAppPurchasesV2GetToManyRelatedRequest {
	return ApiAppsInAppPurchasesV2GetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasesV2Response
func (a *AppsAPIService) AppsInAppPurchasesV2GetToManyRelatedExecute(r ApiAppsInAppPurchasesV2GetToManyRelatedRequest) (*InAppPurchasesV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsInAppPurchasesV2GetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/inAppPurchasesV2"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterProductId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[productId]", r.filterProductId, "form", "csv")
	}
	if r.filterName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[name]", r.filterName, "form", "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "form", "csv")
	}
	if r.filterInAppPurchaseType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[inAppPurchaseType]", r.filterInAppPurchaseType, "form", "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "form", "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "form", "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "form", "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "form", "csv")
	}
	if r.fieldsInAppPurchaseAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAvailabilities]", r.fieldsInAppPurchaseAvailabilities, "form", "csv")
	}
	if r.fieldsInAppPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseImages]", r.fieldsInAppPurchaseImages, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "form", "")
	}
	if r.limitImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[images]", r.limitImages, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsMarketplaceSearchDetails *[]string
}

// the fields to include for returned resources of type marketplaceSearchDetails
func (r ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest) FieldsMarketplaceSearchDetails(fieldsMarketplaceSearchDetails []string) ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest {
	r.fieldsMarketplaceSearchDetails = &fieldsMarketplaceSearchDetails
	return r
}

func (r ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest) Execute() (*MarketplaceSearchDetailResponse, *http.Response, error) {
	return r.ApiService.AppsMarketplaceSearchDetailGetToOneRelatedExecute(r)
}

/*
AppsMarketplaceSearchDetailGetToOneRelated Method for AppsMarketplaceSearchDetailGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsMarketplaceSearchDetailGetToOneRelated(ctx context.Context, id string) ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest {
	return ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return MarketplaceSearchDetailResponse
func (a *AppsAPIService) AppsMarketplaceSearchDetailGetToOneRelatedExecute(r ApiAppsMarketplaceSearchDetailGetToOneRelatedRequest) (*MarketplaceSearchDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MarketplaceSearchDetailResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsMarketplaceSearchDetailGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/marketplaceSearchDetail"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsMarketplaceSearchDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[marketplaceSearchDetails]", r.fieldsMarketplaceSearchDetails, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPerfPowerMetricsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterPlatform *[]string
	filterMetricType *[]string
	filterDeviceType *[]string
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;metricType&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterMetricType(filterMetricType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterMetricType = &filterMetricType
	return r
}

// filter by attribute &#39;deviceType&#39;
func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) FilterDeviceType(filterDeviceType []string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	r.filterDeviceType = &filterDeviceType
	return r
}

func (r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) Execute() (*XcodeMetrics, *http.Response, error) {
	return r.ApiService.AppsPerfPowerMetricsGetToManyRelatedExecute(r)
}

/*
AppsPerfPowerMetricsGetToManyRelated Method for AppsPerfPowerMetricsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPerfPowerMetricsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsPerfPowerMetricsGetToManyRelated(ctx context.Context, id string) ApiAppsPerfPowerMetricsGetToManyRelatedRequest {
	return ApiAppsPerfPowerMetricsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return XcodeMetrics
func (a *AppsAPIService) AppsPerfPowerMetricsGetToManyRelatedExecute(r ApiAppsPerfPowerMetricsGetToManyRelatedRequest) (*XcodeMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *XcodeMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPerfPowerMetricsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/perfPowerMetrics"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "form", "csv")
	}
	if r.filterMetricType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[metricType]", r.filterMetricType, "form", "csv")
	}
	if r.filterDeviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[deviceType]", r.filterDeviceType, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.apple.xcode-metrics+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreOrderGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsAppPreOrders *[]string
}

// the fields to include for returned resources of type appPreOrders
func (r ApiAppsPreOrderGetToOneRelatedRequest) FieldsAppPreOrders(fieldsAppPreOrders []string) ApiAppsPreOrderGetToOneRelatedRequest {
	r.fieldsAppPreOrders = &fieldsAppPreOrders
	return r
}

func (r ApiAppsPreOrderGetToOneRelatedRequest) Execute() (*AppPreOrderWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsPreOrderGetToOneRelatedExecute(r)
}

/*
AppsPreOrderGetToOneRelated Method for AppsPreOrderGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPreOrderGetToOneRelatedRequest

Deprecated
*/
func (a *AppsAPIService) AppsPreOrderGetToOneRelated(ctx context.Context, id string) ApiAppsPreOrderGetToOneRelatedRequest {
	return ApiAppsPreOrderGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPreOrderWithoutIncludesResponse
// Deprecated
func (a *AppsAPIService) AppsPreOrderGetToOneRelatedExecute(r ApiAppsPreOrderGetToOneRelatedRequest) (*AppPreOrderWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPreOrderWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPreOrderGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppPreOrders != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appPreOrders]", r.fieldsAppPreOrders, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPreReleaseVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsPreReleaseVersions *[]string
	limit *int32
}

// the fields to include for returned resources of type preReleaseVersions
func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) FieldsPreReleaseVersions(fieldsPreReleaseVersions []string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.fieldsPreReleaseVersions = &fieldsPreReleaseVersions
	return r
}

// maximum resources per page
func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) Execute() (*PreReleaseVersionsWithoutIncludesResponse, *http.Response, error) {
	return r.ApiService.AppsPreReleaseVersionsGetToManyRelatedExecute(r)
}

/*
AppsPreReleaseVersionsGetToManyRelated Method for AppsPreReleaseVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPreReleaseVersionsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsPreReleaseVersionsGetToManyRelated(ctx context.Context, id string) ApiAppsPreReleaseVersionsGetToManyRelatedRequest {
	return ApiAppsPreReleaseVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PreReleaseVersionsWithoutIncludesResponse
func (a *AppsAPIService) AppsPreReleaseVersionsGetToManyRelatedExecute(r ApiAppsPreReleaseVersionsGetToManyRelatedRequest) (*PreReleaseVersionsWithoutIncludesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreReleaseVersionsWithoutIncludesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPreReleaseVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/preReleaseVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPreReleaseVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[preReleaseVersions]", r.fieldsPreReleaseVersions, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsPromotedPurchaseImages *[]string
	limit *int32
	include *[]string
	limitPromotionImages *int32
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// maximum resources per page
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Limit(limit int32) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Include(include []string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related promotionImages returned (when they are included)
// Deprecated
func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

func (r ApiAppsPromotedPurchasesGetToManyRelatedRequest) Execute() (*PromotedPurchasesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelatedExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelated Method for AppsPromotedPurchasesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPromotedPurchasesGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsPromotedPurchasesGetToManyRelated(ctx context.Context, id string) ApiAppsPromotedPurchasesGetToManyRelatedRequest {
	return ApiAppsPromotedPurchasesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchasesResponse
func (a *AppsAPIService) AppsPromotedPurchasesGetToManyRelatedExecute(r ApiAppsPromotedPurchasesGetToManyRelatedRequest) (*PromotedPurchasesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchasesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPromotedPurchasesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	limit *int32
}

// maximum resources per page
func (r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) Limit(limit int32) ApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) Execute() (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesGetToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesGetToManyRelationship Method for AppsPromotedPurchasesGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPromotedPurchasesGetToManyRelationshipRequest
*/
func (a *AppsAPIService) AppsPromotedPurchasesGetToManyRelationship(ctx context.Context, id string) ApiAppsPromotedPurchasesGetToManyRelationshipRequest {
	return ApiAppsPromotedPurchasesGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppPromotedPurchasesLinkagesResponse
func (a *AppsAPIService) AppsPromotedPurchasesGetToManyRelationshipExecute(r ApiAppsPromotedPurchasesGetToManyRelationshipRequest) (*AppPromotedPurchasesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppPromotedPurchasesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPromotedPurchasesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	appPromotedPurchasesLinkagesRequest *AppPromotedPurchasesLinkagesRequest
}

// List of related linkages
func (r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) AppPromotedPurchasesLinkagesRequest(appPromotedPurchasesLinkagesRequest AppPromotedPurchasesLinkagesRequest) ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	r.appPromotedPurchasesLinkagesRequest = &appPromotedPurchasesLinkagesRequest
	return r
}

func (r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.AppsPromotedPurchasesReplaceToManyRelationshipExecute(r)
}

/*
AppsPromotedPurchasesReplaceToManyRelationship Method for AppsPromotedPurchasesReplaceToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest
*/
func (a *AppsAPIService) AppsPromotedPurchasesReplaceToManyRelationship(ctx context.Context, id string) ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest {
	return ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *AppsAPIService) AppsPromotedPurchasesReplaceToManyRelationshipExecute(r ApiAppsPromotedPurchasesReplaceToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsPromotedPurchasesReplaceToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/relationships/promotedPurchases"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appPromotedPurchasesLinkagesRequest == nil {
		return nil, reportError("appPromotedPurchasesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appPromotedPurchasesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAppsReviewSubmissionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterPlatform *[]string
	filterState *[]string
	fieldsReviewSubmissions *[]string
	fieldsApps *[]string
	fieldsReviewSubmissionItems *[]string
	fieldsAppStoreVersions *[]string
	fieldsActors *[]string
	limit *int32
	include *[]string
	limitItems *int32
}

// filter by attribute &#39;platform&#39;
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterPlatform(filterPlatform []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterPlatform = &filterPlatform
	return r
}

// filter by attribute &#39;state&#39;
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FilterState(filterState []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.filterState = &filterState
	return r
}

// the fields to include for returned resources of type reviewSubmissions
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissions(fieldsReviewSubmissions []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissions = &fieldsReviewSubmissions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsApps(fieldsApps []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type reviewSubmissionItems
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsReviewSubmissionItems(fieldsReviewSubmissionItems []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsReviewSubmissionItems = &fieldsReviewSubmissionItems
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type actors
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) FieldsActors(fieldsActors []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.fieldsActors = &fieldsActors
	return r
}

// maximum resources per page
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Limit(limit int32) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Include(include []string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related items returned (when they are included)
func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) LimitItems(limitItems int32) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	r.limitItems = &limitItems
	return r
}

func (r ApiAppsReviewSubmissionsGetToManyRelatedRequest) Execute() (*ReviewSubmissionsResponse, *http.Response, error) {
	return r.ApiService.AppsReviewSubmissionsGetToManyRelatedExecute(r)
}

/*
AppsReviewSubmissionsGetToManyRelated Method for AppsReviewSubmissionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsReviewSubmissionsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsReviewSubmissionsGetToManyRelated(ctx context.Context, id string) ApiAppsReviewSubmissionsGetToManyRelatedRequest {
	return ApiAppsReviewSubmissionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ReviewSubmissionsResponse
func (a *AppsAPIService) AppsReviewSubmissionsGetToManyRelatedExecute(r ApiAppsReviewSubmissionsGetToManyRelatedRequest) (*ReviewSubmissionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReviewSubmissionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsReviewSubmissionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/reviewSubmissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPlatform != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[platform]", r.filterPlatform, "form", "csv")
	}
	if r.filterState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[state]", r.filterState, "form", "csv")
	}
	if r.fieldsReviewSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissions]", r.fieldsReviewSubmissions, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsReviewSubmissionItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[reviewSubmissionItems]", r.fieldsReviewSubmissionItems, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsActors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[actors]", r.fieldsActors, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[items]", r.limitItems, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	fieldsSubscriptionGracePeriods *[]string
}

// the fields to include for returned resources of type subscriptionGracePeriods
func (r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) FieldsSubscriptionGracePeriods(fieldsSubscriptionGracePeriods []string) ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	r.fieldsSubscriptionGracePeriods = &fieldsSubscriptionGracePeriods
	return r
}

func (r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) Execute() (*SubscriptionGracePeriodResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGracePeriodGetToOneRelatedExecute(r)
}

/*
AppsSubscriptionGracePeriodGetToOneRelated Method for AppsSubscriptionGracePeriodGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest
*/
func (a *AppsAPIService) AppsSubscriptionGracePeriodGetToOneRelated(ctx context.Context, id string) ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest {
	return ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionGracePeriodResponse
func (a *AppsAPIService) AppsSubscriptionGracePeriodGetToOneRelatedExecute(r ApiAppsSubscriptionGracePeriodGetToOneRelatedRequest) (*SubscriptionGracePeriodResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionGracePeriodResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsSubscriptionGracePeriodGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGracePeriod"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionGracePeriods != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGracePeriods]", r.fieldsSubscriptionGracePeriods, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsSubscriptionGroupsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	filterReferenceName *[]string
	filterSubscriptionsState *[]string
	sort *[]string
	fieldsSubscriptionGroups *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionGroupLocalizations *[]string
	limit *int32
	include *[]string
	limitSubscriptions *int32
	limitSubscriptionGroupLocalizations *int32
}

// filter by attribute &#39;referenceName&#39;
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterReferenceName(filterReferenceName []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterReferenceName = &filterReferenceName
	return r
}

// filter by attribute &#39;subscriptions.state&#39;
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FilterSubscriptionsState(filterSubscriptionsState []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.filterSubscriptionsState = &filterSubscriptionsState
	return r
}

// comma-separated list of sort expressions; resources will be sorted as specified
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Sort(sort []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.sort = &sort
	return r
}

// the fields to include for returned resources of type subscriptionGroups
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroups(fieldsSubscriptionGroups []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroups = &fieldsSubscriptionGroups
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionGroupLocalizations
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) FieldsSubscriptionGroupLocalizations(fieldsSubscriptionGroupLocalizations []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.fieldsSubscriptionGroupLocalizations = &fieldsSubscriptionGroupLocalizations
	return r
}

// maximum resources per page
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Limit(limit int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Include(include []string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subscriptions returned (when they are included)
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptions(limitSubscriptions int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptions = &limitSubscriptions
	return r
}

// maximum number of related subscriptionGroupLocalizations returned (when they are included)
func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) LimitSubscriptionGroupLocalizations(limitSubscriptionGroupLocalizations int32) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	r.limitSubscriptionGroupLocalizations = &limitSubscriptionGroupLocalizations
	return r
}

func (r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) Execute() (*SubscriptionGroupsResponse, *http.Response, error) {
	return r.ApiService.AppsSubscriptionGroupsGetToManyRelatedExecute(r)
}

/*
AppsSubscriptionGroupsGetToManyRelated Method for AppsSubscriptionGroupsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsSubscriptionGroupsGetToManyRelatedRequest
*/
func (a *AppsAPIService) AppsSubscriptionGroupsGetToManyRelated(ctx context.Context, id string) ApiAppsSubscriptionGroupsGetToManyRelatedRequest {
	return ApiAppsSubscriptionGroupsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionGroupsResponse
func (a *AppsAPIService) AppsSubscriptionGroupsGetToManyRelatedExecute(r ApiAppsSubscriptionGroupsGetToManyRelatedRequest) (*SubscriptionGroupsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionGroupsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsSubscriptionGroupsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}/subscriptionGroups"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterReferenceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[referenceName]", r.filterReferenceName, "form", "csv")
	}
	if r.filterSubscriptionsState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptions.state]", r.filterSubscriptionsState, "form", "csv")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "csv")
	}
	if r.fieldsSubscriptionGroups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroups]", r.fieldsSubscriptionGroups, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionGroupLocalizations]", r.fieldsSubscriptionGroupLocalizations, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptions]", r.limitSubscriptions, "form", "")
	}
	if r.limitSubscriptionGroupLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionGroupLocalizations]", r.limitSubscriptionGroupLocalizations, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppsUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *AppsAPIService
	id string
	appUpdateRequest *AppUpdateRequest
}

// App representation
func (r ApiAppsUpdateInstanceRequest) AppUpdateRequest(appUpdateRequest AppUpdateRequest) ApiAppsUpdateInstanceRequest {
	r.appUpdateRequest = &appUpdateRequest
	return r
}

func (r ApiAppsUpdateInstanceRequest) Execute() (*AppResponse, *http.Response, error) {
	return r.ApiService.AppsUpdateInstanceExecute(r)
}

/*
AppsUpdateInstance Method for AppsUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppsUpdateInstanceRequest
*/
func (a *AppsAPIService) AppsUpdateInstance(ctx context.Context, id string) ApiAppsUpdateInstanceRequest {
	return ApiAppsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppResponse
func (a *AppsAPIService) AppsUpdateInstanceExecute(r ApiAppsUpdateInstanceRequest) (*AppResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppsAPIService.AppsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/apps/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
