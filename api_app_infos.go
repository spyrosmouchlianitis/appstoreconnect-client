/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect-client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AppInfosAPIService AppInfosAPI service
type AppInfosAPIService service

type ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAgeRatingDeclarations *[]string
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

func (r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) Execute() (*AgeRatingDeclarationResponse, *http.Response, error) {
	return r.ApiService.AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r)
}

/*
AppInfosAgeRatingDeclarationGetToOneRelated Method for AppInfosAgeRatingDeclarationGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosAgeRatingDeclarationGetToOneRelated(ctx context.Context, id string) ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest {
	return ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AgeRatingDeclarationResponse
func (a *AppInfosAPIService) AppInfosAgeRatingDeclarationGetToOneRelatedExecute(r ApiAppInfosAgeRatingDeclarationGetToOneRelatedRequest) (*AgeRatingDeclarationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AgeRatingDeclarationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosAgeRatingDeclarationGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/ageRatingDeclaration"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	filterLocale *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsAppInfos *[]string
	limit *int32
	include *[]string
}

// filter by attribute &#39;locale&#39;
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FilterLocale(filterLocale []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.filterLocale = &filterLocale
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appInfos
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// maximum resources per page
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Include(include []string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) Execute() (*AppInfoLocalizationsResponse, *http.Response, error) {
	return r.ApiService.AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r)
}

/*
AppInfosAppInfoLocalizationsGetToManyRelated Method for AppInfosAppInfoLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosAppInfoLocalizationsGetToManyRelated(ctx context.Context, id string) ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest {
	return ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoLocalizationsResponse
func (a *AppInfosAPIService) AppInfosAppInfoLocalizationsGetToManyRelatedExecute(r ApiAppInfosAppInfoLocalizationsGetToManyRelatedRequest) (*AppInfoLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosAppInfoLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/appInfoLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterLocale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[locale]", r.filterLocale, "form", "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "form", "csv")
	}
	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosGetInstanceRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppInfos *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppInfoLocalizations *[]string
	fieldsAppCategories *[]string
	include *[]string
	limitAppInfoLocalizations *int32
}

// the fields to include for returned resources of type appInfos
func (r ApiAppInfosGetInstanceRequest) FieldsAppInfos(fieldsAppInfos []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppInfos = &fieldsAppInfos
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiAppInfosGetInstanceRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appInfoLocalizations
func (r ApiAppInfosGetInstanceRequest) FieldsAppInfoLocalizations(fieldsAppInfoLocalizations []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppInfoLocalizations = &fieldsAppInfoLocalizations
	return r
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosGetInstanceRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosGetInstanceRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosGetInstanceRequest) Include(include []string) ApiAppInfosGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related appInfoLocalizations returned (when they are included)
func (r ApiAppInfosGetInstanceRequest) LimitAppInfoLocalizations(limitAppInfoLocalizations int32) ApiAppInfosGetInstanceRequest {
	r.limitAppInfoLocalizations = &limitAppInfoLocalizations
	return r
}

func (r ApiAppInfosGetInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosGetInstanceExecute(r)
}

/*
AppInfosGetInstance Method for AppInfosGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosGetInstanceRequest
*/
func (a *AppInfosAPIService) AppInfosGetInstance(ctx context.Context, id string) ApiAppInfosGetInstanceRequest {
	return ApiAppInfosGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoResponse
func (a *AppInfosAPIService) AppInfosGetInstanceExecute(r ApiAppInfosGetInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppInfos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfos]", r.fieldsAppInfos, "form", "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "form", "csv")
	}
	if r.fieldsAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appInfoLocalizations]", r.fieldsAppInfoLocalizations, "form", "csv")
	}
	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppInfoLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appInfoLocalizations]", r.limitAppInfoLocalizations, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimaryCategoryGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosPrimaryCategoryGetToOneRelated Method for AppInfosPrimaryCategoryGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosPrimaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosPrimaryCategoryGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimaryCategoryGetToOneRelatedRequest {
	return ApiAppInfosPrimaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosPrimaryCategoryGetToOneRelatedExecute(r ApiAppInfosPrimaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosPrimaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryOneGetToOneRelated Method for AppInfosPrimarySubcategoryOneGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosPrimarySubcategoryOneGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest {
	return ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosPrimarySubcategoryOneGetToOneRelatedExecute(r ApiAppInfosPrimarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosPrimarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosPrimarySubcategoryTwoGetToOneRelated Method for AppInfosPrimarySubcategoryTwoGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosPrimarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest {
	return ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosPrimarySubcategoryTwoGetToOneRelatedExecute(r ApiAppInfosPrimarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosPrimarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/primarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondaryCategoryGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondaryCategoryGetToOneRelatedExecute(r)
}

/*
AppInfosSecondaryCategoryGetToOneRelated Method for AppInfosSecondaryCategoryGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosSecondaryCategoryGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosSecondaryCategoryGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondaryCategoryGetToOneRelatedRequest {
	return ApiAppInfosSecondaryCategoryGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosSecondaryCategoryGetToOneRelatedExecute(r ApiAppInfosSecondaryCategoryGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosSecondaryCategoryGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondaryCategory"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryOneGetToOneRelated Method for AppInfosSecondarySubcategoryOneGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosSecondarySubcategoryOneGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest {
	return ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosSecondarySubcategoryOneGetToOneRelatedExecute(r ApiAppInfosSecondarySubcategoryOneGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosSecondarySubcategoryOneGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryOne"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	fieldsAppCategories *[]string
	include *[]string
	limitSubcategories *int32
}

// the fields to include for returned resources of type appCategories
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) FieldsAppCategories(fieldsAppCategories []string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.fieldsAppCategories = &fieldsAppCategories
	return r
}

// comma-separated list of relationships to include
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Include(include []string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related subcategories returned (when they are included)
func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) LimitSubcategories(limitSubcategories int32) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	r.limitSubcategories = &limitSubcategories
	return r
}

func (r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) Execute() (*AppCategoryResponse, *http.Response, error) {
	return r.ApiService.AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r)
}

/*
AppInfosSecondarySubcategoryTwoGetToOneRelated Method for AppInfosSecondarySubcategoryTwoGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest
*/
func (a *AppInfosAPIService) AppInfosSecondarySubcategoryTwoGetToOneRelated(ctx context.Context, id string) ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest {
	return ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppCategoryResponse
func (a *AppInfosAPIService) AppInfosSecondarySubcategoryTwoGetToOneRelatedExecute(r ApiAppInfosSecondarySubcategoryTwoGetToOneRelatedRequest) (*AppCategoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppCategoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosSecondarySubcategoryTwoGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}/secondarySubcategoryTwo"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppCategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appCategories]", r.fieldsAppCategories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitSubcategories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subcategories]", r.limitSubcategories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppInfosUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *AppInfosAPIService
	id string
	appInfoUpdateRequest *AppInfoUpdateRequest
}

// AppInfo representation
func (r ApiAppInfosUpdateInstanceRequest) AppInfoUpdateRequest(appInfoUpdateRequest AppInfoUpdateRequest) ApiAppInfosUpdateInstanceRequest {
	r.appInfoUpdateRequest = &appInfoUpdateRequest
	return r
}

func (r ApiAppInfosUpdateInstanceRequest) Execute() (*AppInfoResponse, *http.Response, error) {
	return r.ApiService.AppInfosUpdateInstanceExecute(r)
}

/*
AppInfosUpdateInstance Method for AppInfosUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiAppInfosUpdateInstanceRequest
*/
func (a *AppInfosAPIService) AppInfosUpdateInstance(ctx context.Context, id string) ApiAppInfosUpdateInstanceRequest {
	return ApiAppInfosUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppInfoResponse
func (a *AppInfosAPIService) AppInfosUpdateInstanceExecute(r ApiAppInfosUpdateInstanceRequest) (*AppInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AppInfosAPIService.AppInfosUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/appInfos/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appInfoUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("appInfoUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appInfoUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
