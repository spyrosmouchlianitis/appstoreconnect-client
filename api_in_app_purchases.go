/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnectclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InAppPurchasesAPIService InAppPurchasesAPI service
type InAppPurchasesAPIService service

type ApiInAppPurchasesGetInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchases *[]string
	include *[]string
	limitApps *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesGetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesGetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesGetInstanceRequest) Include(include []string) ApiInAppPurchasesGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related apps returned (when they are included)
func (r ApiInAppPurchasesGetInstanceRequest) LimitApps(limitApps int32) ApiInAppPurchasesGetInstanceRequest {
	r.limitApps = &limitApps
	return r
}

func (r ApiInAppPurchasesGetInstanceRequest) Execute() (*InAppPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesGetInstanceExecute(r)
}

/*
InAppPurchasesGetInstance Method for InAppPurchasesGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesGetInstanceRequest

Deprecated
*/
func (a *InAppPurchasesAPIService) InAppPurchasesGetInstance(ctx context.Context, id string) ApiInAppPurchasesGetInstanceRequest {
	return ApiInAppPurchasesGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseResponse
// Deprecated
func (a *InAppPurchasesAPIService) InAppPurchasesGetInstanceExecute(r ApiInAppPurchasesGetInstanceRequest) (*InAppPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[apps]", r.limitApps, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsInAppPurchases *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated Method for InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest {
	return ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseAppStoreReviewScreenshotResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedExecute(r ApiInAppPurchasesV2AppStoreReviewScreenshotGetToOneRelatedRequest) (*InAppPurchaseAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2AppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2ContentGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchaseContents *[]string
	fieldsInAppPurchases *[]string
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiInAppPurchasesV2ContentGetToOneRelatedRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiInAppPurchasesV2ContentGetToOneRelatedRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2ContentGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2ContentGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2ContentGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesV2ContentGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesV2ContentGetToOneRelatedRequest) Execute() (*InAppPurchaseContentResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2ContentGetToOneRelatedExecute(r)
}

/*
InAppPurchasesV2ContentGetToOneRelated Method for InAppPurchasesV2ContentGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2ContentGetToOneRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2ContentGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesV2ContentGetToOneRelatedRequest {
	return ApiInAppPurchasesV2ContentGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseContentResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2ContentGetToOneRelatedExecute(r ApiInAppPurchasesV2ContentGetToOneRelatedRequest) (*InAppPurchaseContentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseContentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2ContentGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/content"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2CreateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	inAppPurchaseV2CreateRequest *InAppPurchaseV2CreateRequest
}

// InAppPurchase representation
func (r ApiInAppPurchasesV2CreateInstanceRequest) InAppPurchaseV2CreateRequest(inAppPurchaseV2CreateRequest InAppPurchaseV2CreateRequest) ApiInAppPurchasesV2CreateInstanceRequest {
	r.inAppPurchaseV2CreateRequest = &inAppPurchaseV2CreateRequest
	return r
}

func (r ApiInAppPurchasesV2CreateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2CreateInstanceExecute(r)
}

/*
InAppPurchasesV2CreateInstance Method for InAppPurchasesV2CreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInAppPurchasesV2CreateInstanceRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2CreateInstance(ctx context.Context) ApiInAppPurchasesV2CreateInstanceRequest {
	return ApiInAppPurchasesV2CreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesAPIService) InAppPurchasesV2CreateInstanceExecute(r ApiInAppPurchasesV2CreateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2CreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2CreateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2CreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2CreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2DeleteInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
}

func (r ApiInAppPurchasesV2DeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.InAppPurchasesV2DeleteInstanceExecute(r)
}

/*
InAppPurchasesV2DeleteInstance Method for InAppPurchasesV2DeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2DeleteInstanceRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2DeleteInstance(ctx context.Context, id string) ApiInAppPurchasesV2DeleteInstanceRequest {
	return ApiInAppPurchasesV2DeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *InAppPurchasesAPIService) InAppPurchasesV2DeleteInstanceExecute(r ApiInAppPurchasesV2DeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2DeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2GetInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchases *[]string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsInAppPurchaseContents *[]string
	fieldsInAppPurchaseAppStoreReviewScreenshots *[]string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchaseAvailabilities *[]string
	fieldsInAppPurchaseImages *[]string
	include *[]string
	limitImages *int32
	limitInAppPurchaseLocalizations *int32
	limitPricePoints *int32
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type inAppPurchaseContents
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchaseContents(fieldsInAppPurchaseContents []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchaseContents = &fieldsInAppPurchaseContents
	return r
}

// the fields to include for returned resources of type inAppPurchaseAppStoreReviewScreenshots
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchaseAppStoreReviewScreenshots(fieldsInAppPurchaseAppStoreReviewScreenshots []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchaseAppStoreReviewScreenshots = &fieldsInAppPurchaseAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchaseAvailabilities
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchaseAvailabilities(fieldsInAppPurchaseAvailabilities []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchaseAvailabilities = &fieldsInAppPurchaseAvailabilities
	return r
}

// the fields to include for returned resources of type inAppPurchaseImages
func (r ApiInAppPurchasesV2GetInstanceRequest) FieldsInAppPurchaseImages(fieldsInAppPurchaseImages []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.fieldsInAppPurchaseImages = &fieldsInAppPurchaseImages
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2GetInstanceRequest) Include(include []string) ApiInAppPurchasesV2GetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related images returned (when they are included)
func (r ApiInAppPurchasesV2GetInstanceRequest) LimitImages(limitImages int32) ApiInAppPurchasesV2GetInstanceRequest {
	r.limitImages = &limitImages
	return r
}

// maximum number of related inAppPurchaseLocalizations returned (when they are included)
func (r ApiInAppPurchasesV2GetInstanceRequest) LimitInAppPurchaseLocalizations(limitInAppPurchaseLocalizations int32) ApiInAppPurchasesV2GetInstanceRequest {
	r.limitInAppPurchaseLocalizations = &limitInAppPurchaseLocalizations
	return r
}

// maximum number of related pricePoints returned (when they are included)
func (r ApiInAppPurchasesV2GetInstanceRequest) LimitPricePoints(limitPricePoints int32) ApiInAppPurchasesV2GetInstanceRequest {
	r.limitPricePoints = &limitPricePoints
	return r
}

func (r ApiInAppPurchasesV2GetInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2GetInstanceExecute(r)
}

/*
InAppPurchasesV2GetInstance Method for InAppPurchasesV2GetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2GetInstanceRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2GetInstance(ctx context.Context, id string) ApiInAppPurchasesV2GetInstanceRequest {
	return ApiInAppPurchasesV2GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesAPIService) InAppPurchasesV2GetInstanceExecute(r ApiInAppPurchasesV2GetInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "form", "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "form", "csv")
	}
	if r.fieldsInAppPurchaseContents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseContents]", r.fieldsInAppPurchaseContents, "form", "csv")
	}
	if r.fieldsInAppPurchaseAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAppStoreReviewScreenshots]", r.fieldsInAppPurchaseAppStoreReviewScreenshots, "form", "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "form", "csv")
	}
	if r.fieldsInAppPurchaseAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAvailabilities]", r.fieldsInAppPurchaseAvailabilities, "form", "csv")
	}
	if r.fieldsInAppPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseImages]", r.fieldsInAppPurchaseImages, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[images]", r.limitImages, "form", "")
	}
	if r.limitInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[inAppPurchaseLocalizations]", r.limitInAppPurchaseLocalizations, "form", "")
	}
	if r.limitPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[pricePoints]", r.limitPricePoints, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchasePriceSchedules *[]string
	fieldsInAppPurchases *[]string
	fieldsTerritories *[]string
	fieldsInAppPurchasePrices *[]string
	include *[]string
	limitManualPrices *int32
	limitAutomaticPrices *int32
}

// the fields to include for returned resources of type inAppPurchasePriceSchedules
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePriceSchedules(fieldsInAppPurchasePriceSchedules []string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePriceSchedules = &fieldsInAppPurchasePriceSchedules
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type territories
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type inAppPurchasePrices
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) FieldsInAppPurchasePrices(fieldsInAppPurchasePrices []string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.fieldsInAppPurchasePrices = &fieldsInAppPurchasePrices
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related manualPrices returned (when they are included)
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) LimitManualPrices(limitManualPrices int32) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.limitManualPrices = &limitManualPrices
	return r
}

// maximum number of related automaticPrices returned (when they are included)
func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) LimitAutomaticPrices(limitAutomaticPrices int32) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	r.limitAutomaticPrices = &limitAutomaticPrices
	return r
}

func (r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) Execute() (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2IapPriceScheduleGetToOneRelatedExecute(r)
}

/*
InAppPurchasesV2IapPriceScheduleGetToOneRelated Method for InAppPurchasesV2IapPriceScheduleGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2IapPriceScheduleGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest {
	return ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePriceScheduleResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2IapPriceScheduleGetToOneRelatedExecute(r ApiInAppPurchasesV2IapPriceScheduleGetToOneRelatedRequest) (*InAppPurchasePriceScheduleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePriceScheduleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2IapPriceScheduleGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/iapPriceSchedule"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchasePriceSchedules != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePriceSchedules]", r.fieldsInAppPurchasePriceSchedules, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.fieldsInAppPurchasePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePrices]", r.fieldsInAppPurchasePrices, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitManualPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[manualPrices]", r.limitManualPrices, "form", "")
	}
	if r.limitAutomaticPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[automaticPrices]", r.limitAutomaticPrices, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2ImagesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchaseImages *[]string
	fieldsInAppPurchases *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseImages
func (r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) FieldsInAppPurchaseImages(fieldsInAppPurchaseImages []string) ApiInAppPurchasesV2ImagesGetToManyRelatedRequest {
	r.fieldsInAppPurchaseImages = &fieldsInAppPurchaseImages
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2ImagesGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// maximum resources per page
func (r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) Limit(limit int32) ApiInAppPurchasesV2ImagesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) Include(include []string) ApiInAppPurchasesV2ImagesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) Execute() (*InAppPurchaseImagesResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2ImagesGetToManyRelatedExecute(r)
}

/*
InAppPurchasesV2ImagesGetToManyRelated Method for InAppPurchasesV2ImagesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2ImagesGetToManyRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2ImagesGetToManyRelated(ctx context.Context, id string) ApiInAppPurchasesV2ImagesGetToManyRelatedRequest {
	return ApiInAppPurchasesV2ImagesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseImagesResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2ImagesGetToManyRelatedExecute(r ApiInAppPurchasesV2ImagesGetToManyRelatedRequest) (*InAppPurchaseImagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseImagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2ImagesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseImages]", r.fieldsInAppPurchaseImages, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchaseAvailabilities *[]string
	fieldsTerritories *[]string
	include *[]string
	limitAvailableTerritories *int32
}

// the fields to include for returned resources of type inAppPurchaseAvailabilities
func (r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) FieldsInAppPurchaseAvailabilities(fieldsInAppPurchaseAvailabilities []string) ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest {
	r.fieldsInAppPurchaseAvailabilities = &fieldsInAppPurchaseAvailabilities
	return r
}

// the fields to include for returned resources of type territories
func (r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

func (r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) Execute() (*InAppPurchaseAvailabilityResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedExecute(r)
}

/*
InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated Method for InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest {
	return ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseAvailabilityResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedExecute(r ApiInAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelatedRequest) (*InAppPurchaseAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2InAppPurchaseAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/inAppPurchaseAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseAvailabilities]", r.fieldsInAppPurchaseAvailabilities, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsInAppPurchaseLocalizations *[]string
	fieldsInAppPurchases *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type inAppPurchaseLocalizations
func (r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchaseLocalizations(fieldsInAppPurchaseLocalizations []string) ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchaseLocalizations = &fieldsInAppPurchaseLocalizations
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// maximum resources per page
func (r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) Include(include []string) ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) Execute() (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated Method for InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated(ctx context.Context, id string) ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest {
	return ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseLocalizationsResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedExecute(r ApiInAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelatedRequest) (*InAppPurchaseLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2InAppPurchaseLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/inAppPurchaseLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsInAppPurchaseLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchaseLocalizations]", r.fieldsInAppPurchaseLocalizations, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	filterTerritory *[]string
	fieldsInAppPurchasePricePoints *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type inAppPurchasePricePoints
func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) FieldsInAppPurchasePricePoints(fieldsInAppPurchasePricePoints []string) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	r.fieldsInAppPurchasePricePoints = &fieldsInAppPurchasePricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) Limit(limit int32) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) Include(include []string) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) Execute() (*InAppPurchasePricePointsResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2PricePointsGetToManyRelatedExecute(r)
}

/*
InAppPurchasesV2PricePointsGetToManyRelated Method for InAppPurchasesV2PricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2PricePointsGetToManyRelated(ctx context.Context, id string) ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest {
	return ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchasePricePointsResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2PricePointsGetToManyRelatedExecute(r ApiInAppPurchasesV2PricePointsGetToManyRelatedRequest) (*InAppPurchasePricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchasePricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2PricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsInAppPurchasePricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchasePricePoints]", r.fieldsInAppPurchasePricePoints, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsPromotedPurchaseImages *[]string
	include *[]string
	limitPromotionImages *int32
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// comma-separated list of relationships to include
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) Include(include []string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related promotionImages returned (when they are included)
// Deprecated
func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

func (r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2PromotedPurchaseGetToOneRelatedExecute(r)
}

/*
InAppPurchasesV2PromotedPurchaseGetToOneRelated Method for InAppPurchasesV2PromotedPurchaseGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2PromotedPurchaseGetToOneRelated(ctx context.Context, id string) ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest {
	return ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchaseResponse
func (a *InAppPurchasesAPIService) InAppPurchasesV2PromotedPurchaseGetToOneRelatedExecute(r ApiInAppPurchasesV2PromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2PromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInAppPurchasesV2UpdateInstanceRequest struct {
	ctx context.Context
	ApiService *InAppPurchasesAPIService
	id string
	inAppPurchaseV2UpdateRequest *InAppPurchaseV2UpdateRequest
}

// InAppPurchase representation
func (r ApiInAppPurchasesV2UpdateInstanceRequest) InAppPurchaseV2UpdateRequest(inAppPurchaseV2UpdateRequest InAppPurchaseV2UpdateRequest) ApiInAppPurchasesV2UpdateInstanceRequest {
	r.inAppPurchaseV2UpdateRequest = &inAppPurchaseV2UpdateRequest
	return r
}

func (r ApiInAppPurchasesV2UpdateInstanceRequest) Execute() (*InAppPurchaseV2Response, *http.Response, error) {
	return r.ApiService.InAppPurchasesV2UpdateInstanceExecute(r)
}

/*
InAppPurchasesV2UpdateInstance Method for InAppPurchasesV2UpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiInAppPurchasesV2UpdateInstanceRequest
*/
func (a *InAppPurchasesAPIService) InAppPurchasesV2UpdateInstance(ctx context.Context, id string) ApiInAppPurchasesV2UpdateInstanceRequest {
	return ApiInAppPurchasesV2UpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return InAppPurchaseV2Response
func (a *InAppPurchasesAPIService) InAppPurchasesV2UpdateInstanceExecute(r ApiInAppPurchasesV2UpdateInstanceRequest) (*InAppPurchaseV2Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InAppPurchaseV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InAppPurchasesAPIService.InAppPurchasesV2UpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/inAppPurchases/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.inAppPurchaseV2UpdateRequest == nil {
		return localVarReturnValue, nil, reportError("inAppPurchaseV2UpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.inAppPurchaseV2UpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
