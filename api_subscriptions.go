/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnectclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SubscriptionsAPIService SubscriptionsAPI service
type SubscriptionsAPIService service

type ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptions *[]string
	include *[]string
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) Execute() (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r)
}

/*
SubscriptionsAppStoreReviewScreenshotGetToOneRelated Method for SubscriptionsAppStoreReviewScreenshotGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsAppStoreReviewScreenshotGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest {
	return ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionAppStoreReviewScreenshotResponse
func (a *SubscriptionsAPIService) SubscriptionsAppStoreReviewScreenshotGetToOneRelatedExecute(r ApiSubscriptionsAppStoreReviewScreenshotGetToOneRelatedRequest) (*SubscriptionAppStoreReviewScreenshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionAppStoreReviewScreenshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsAppStoreReviewScreenshotGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/appStoreReviewScreenshot"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsCreateInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	subscriptionCreateRequest *SubscriptionCreateRequest
}

// Subscription representation
func (r ApiSubscriptionsCreateInstanceRequest) SubscriptionCreateRequest(subscriptionCreateRequest SubscriptionCreateRequest) ApiSubscriptionsCreateInstanceRequest {
	r.subscriptionCreateRequest = &subscriptionCreateRequest
	return r
}

func (r ApiSubscriptionsCreateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsCreateInstanceExecute(r)
}

/*
SubscriptionsCreateInstance Method for SubscriptionsCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubscriptionsCreateInstanceRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsCreateInstance(ctx context.Context) ApiSubscriptionsCreateInstanceRequest {
	return ApiSubscriptionsCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsAPIService) SubscriptionsCreateInstanceExecute(r ApiSubscriptionsCreateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsDeleteInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
}

func (r ApiSubscriptionsDeleteInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsDeleteInstanceExecute(r)
}

/*
SubscriptionsDeleteInstance Method for SubscriptionsDeleteInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsDeleteInstanceRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsDeleteInstance(ctx context.Context, id string) ApiSubscriptionsDeleteInstanceRequest {
	return ApiSubscriptionsDeleteInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsAPIService) SubscriptionsDeleteInstanceExecute(r ApiSubscriptionsDeleteInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsDeleteInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsGetInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsSubscriptions *[]string
	fieldsSubscriptionLocalizations *[]string
	fieldsSubscriptionAppStoreReviewScreenshots *[]string
	fieldsSubscriptionIntroductoryOffers *[]string
	fieldsSubscriptionPromotionalOffers *[]string
	fieldsSubscriptionOfferCodes *[]string
	fieldsSubscriptionPrices *[]string
	fieldsPromotedPurchases *[]string
	fieldsSubscriptionAvailabilities *[]string
	fieldsWinBackOffers *[]string
	fieldsSubscriptionImages *[]string
	include *[]string
	limitImages *int32
	limitIntroductoryOffers *int32
	limitOfferCodes *int32
	limitPrices *int32
	limitPromotionalOffers *int32
	limitSubscriptionLocalizations *int32
	limitWinBackOffers *int32
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// the fields to include for returned resources of type subscriptionAppStoreReviewScreenshots
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionAppStoreReviewScreenshots(fieldsSubscriptionAppStoreReviewScreenshots []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionAppStoreReviewScreenshots = &fieldsSubscriptionAppStoreReviewScreenshots
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiSubscriptionsGetInstanceRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type subscriptionAvailabilities
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionAvailabilities(fieldsSubscriptionAvailabilities []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionAvailabilities = &fieldsSubscriptionAvailabilities
	return r
}

// the fields to include for returned resources of type winBackOffers
func (r ApiSubscriptionsGetInstanceRequest) FieldsWinBackOffers(fieldsWinBackOffers []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsWinBackOffers = &fieldsWinBackOffers
	return r
}

// the fields to include for returned resources of type subscriptionImages
func (r ApiSubscriptionsGetInstanceRequest) FieldsSubscriptionImages(fieldsSubscriptionImages []string) ApiSubscriptionsGetInstanceRequest {
	r.fieldsSubscriptionImages = &fieldsSubscriptionImages
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsGetInstanceRequest) Include(include []string) ApiSubscriptionsGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related images returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitImages(limitImages int32) ApiSubscriptionsGetInstanceRequest {
	r.limitImages = &limitImages
	return r
}

// maximum number of related introductoryOffers returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitIntroductoryOffers(limitIntroductoryOffers int32) ApiSubscriptionsGetInstanceRequest {
	r.limitIntroductoryOffers = &limitIntroductoryOffers
	return r
}

// maximum number of related offerCodes returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitOfferCodes(limitOfferCodes int32) ApiSubscriptionsGetInstanceRequest {
	r.limitOfferCodes = &limitOfferCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitPrices(limitPrices int32) ApiSubscriptionsGetInstanceRequest {
	r.limitPrices = &limitPrices
	return r
}

// maximum number of related promotionalOffers returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitPromotionalOffers(limitPromotionalOffers int32) ApiSubscriptionsGetInstanceRequest {
	r.limitPromotionalOffers = &limitPromotionalOffers
	return r
}

// maximum number of related subscriptionLocalizations returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitSubscriptionLocalizations(limitSubscriptionLocalizations int32) ApiSubscriptionsGetInstanceRequest {
	r.limitSubscriptionLocalizations = &limitSubscriptionLocalizations
	return r
}

// maximum number of related winBackOffers returned (when they are included)
func (r ApiSubscriptionsGetInstanceRequest) LimitWinBackOffers(limitWinBackOffers int32) ApiSubscriptionsGetInstanceRequest {
	r.limitWinBackOffers = &limitWinBackOffers
	return r
}

func (r ApiSubscriptionsGetInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsGetInstanceExecute(r)
}

/*
SubscriptionsGetInstance Method for SubscriptionsGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsGetInstanceRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsGetInstance(ctx context.Context, id string) ApiSubscriptionsGetInstanceRequest {
	return ApiSubscriptionsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsAPIService) SubscriptionsGetInstanceExecute(r ApiSubscriptionsGetInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "form", "csv")
	}
	if r.fieldsSubscriptionAppStoreReviewScreenshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAppStoreReviewScreenshots]", r.fieldsSubscriptionAppStoreReviewScreenshots, "form", "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "form", "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "form", "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "form", "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "form", "csv")
	}
	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsSubscriptionAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAvailabilities]", r.fieldsSubscriptionAvailabilities, "form", "csv")
	}
	if r.fieldsWinBackOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[winBackOffers]", r.fieldsWinBackOffers, "form", "csv")
	}
	if r.fieldsSubscriptionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionImages]", r.fieldsSubscriptionImages, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[images]", r.limitImages, "form", "")
	}
	if r.limitIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[introductoryOffers]", r.limitIntroductoryOffers, "form", "")
	}
	if r.limitOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[offerCodes]", r.limitOfferCodes, "form", "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "form", "")
	}
	if r.limitPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionalOffers]", r.limitPromotionalOffers, "form", "")
	}
	if r.limitSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[subscriptionLocalizations]", r.limitSubscriptionLocalizations, "form", "")
	}
	if r.limitWinBackOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[winBackOffers]", r.limitWinBackOffers, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsImagesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsSubscriptionImages *[]string
	fieldsSubscriptions *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type subscriptionImages
func (r ApiSubscriptionsImagesGetToManyRelatedRequest) FieldsSubscriptionImages(fieldsSubscriptionImages []string) ApiSubscriptionsImagesGetToManyRelatedRequest {
	r.fieldsSubscriptionImages = &fieldsSubscriptionImages
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsImagesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsImagesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// maximum resources per page
func (r ApiSubscriptionsImagesGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsImagesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsImagesGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsImagesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsImagesGetToManyRelatedRequest) Execute() (*SubscriptionImagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsImagesGetToManyRelatedExecute(r)
}

/*
SubscriptionsImagesGetToManyRelated Method for SubscriptionsImagesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsImagesGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsImagesGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsImagesGetToManyRelatedRequest {
	return ApiSubscriptionsImagesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionImagesResponse
func (a *SubscriptionsAPIService) SubscriptionsImagesGetToManyRelatedExecute(r ApiSubscriptionsImagesGetToManyRelatedRequest) (*SubscriptionImagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionImagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsImagesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionImages]", r.fieldsSubscriptionImages, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	subscriptionIntroductoryOffersLinkagesRequest *SubscriptionIntroductoryOffersLinkagesRequest
}

// List of related linkages
func (r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) SubscriptionIntroductoryOffersLinkagesRequest(subscriptionIntroductoryOffersLinkagesRequest SubscriptionIntroductoryOffersLinkagesRequest) ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	r.subscriptionIntroductoryOffersLinkagesRequest = &subscriptionIntroductoryOffersLinkagesRequest
	return r
}

func (r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersDeleteToManyRelationship Method for SubscriptionsIntroductoryOffersDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersDeleteToManyRelationship(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest {
	return ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersDeleteToManyRelationshipExecute(r ApiSubscriptionsIntroductoryOffersDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsIntroductoryOffersDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionIntroductoryOffersLinkagesRequest == nil {
		return nil, reportError("subscriptionIntroductoryOffersLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionIntroductoryOffersLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	filterTerritory *[]string
	fieldsSubscriptionIntroductoryOffers *[]string
	fieldsSubscriptions *[]string
	fieldsTerritories *[]string
	fieldsSubscriptionPricePoints *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionIntroductoryOffers
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionIntroductoryOffers(fieldsSubscriptionIntroductoryOffers []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionIntroductoryOffers = &fieldsSubscriptionIntroductoryOffers
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// maximum resources per page
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) Execute() (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelated Method for SubscriptionsIntroductoryOffersGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest {
	return ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionIntroductoryOffersResponse
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersGetToManyRelatedExecute(r ApiSubscriptionsIntroductoryOffersGetToManyRelatedRequest) (*SubscriptionIntroductoryOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionIntroductoryOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsIntroductoryOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsSubscriptionIntroductoryOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionIntroductoryOffers]", r.fieldsSubscriptionIntroductoryOffers, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	limit *int32
}

// maximum resources per page
func (r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Limit(limit int32) ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) Execute() (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r)
}

/*
SubscriptionsIntroductoryOffersGetToManyRelationship Method for SubscriptionsIntroductoryOffersGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersGetToManyRelationship(ctx context.Context, id string) ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest {
	return ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionIntroductoryOffersLinkagesResponse
func (a *SubscriptionsAPIService) SubscriptionsIntroductoryOffersGetToManyRelationshipExecute(r ApiSubscriptionsIntroductoryOffersGetToManyRelationshipRequest) (*SubscriptionIntroductoryOffersLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionIntroductoryOffersLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsIntroductoryOffersGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/introductoryOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsOfferCodesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	filterTerritory *[]string
	fieldsSubscriptionOfferCodes *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionOfferCodeOneTimeUseCodes *[]string
	fieldsSubscriptionOfferCodeCustomCodes *[]string
	fieldsSubscriptionOfferCodePrices *[]string
	limit *int32
	include *[]string
	limitOneTimeUseCodes *int32
	limitCustomCodes *int32
	limitPrices *int32
}

// filter by territory
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodes(fieldsSubscriptionOfferCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodes = &fieldsSubscriptionOfferCodes
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeOneTimeUseCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeOneTimeUseCodes(fieldsSubscriptionOfferCodeOneTimeUseCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeOneTimeUseCodes = &fieldsSubscriptionOfferCodeOneTimeUseCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodeCustomCodes
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodeCustomCodes(fieldsSubscriptionOfferCodeCustomCodes []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodeCustomCodes = &fieldsSubscriptionOfferCodeCustomCodes
	return r
}

// the fields to include for returned resources of type subscriptionOfferCodePrices
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) FieldsSubscriptionOfferCodePrices(fieldsSubscriptionOfferCodePrices []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.fieldsSubscriptionOfferCodePrices = &fieldsSubscriptionOfferCodePrices
	return r
}

// maximum resources per page
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related oneTimeUseCodes returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitOneTimeUseCodes(limitOneTimeUseCodes int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitOneTimeUseCodes = &limitOneTimeUseCodes
	return r
}

// maximum number of related customCodes returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitCustomCodes(limitCustomCodes int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitCustomCodes = &limitCustomCodes
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) LimitPrices(limitPrices int32) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

func (r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) Execute() (*SubscriptionOfferCodesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsOfferCodesGetToManyRelatedExecute(r)
}

/*
SubscriptionsOfferCodesGetToManyRelated Method for SubscriptionsOfferCodesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsOfferCodesGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsOfferCodesGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsOfferCodesGetToManyRelatedRequest {
	return ApiSubscriptionsOfferCodesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionOfferCodesResponse
func (a *SubscriptionsAPIService) SubscriptionsOfferCodesGetToManyRelatedExecute(r ApiSubscriptionsOfferCodesGetToManyRelatedRequest) (*SubscriptionOfferCodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionOfferCodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsOfferCodesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/offerCodes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsSubscriptionOfferCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodes]", r.fieldsSubscriptionOfferCodes, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsSubscriptionOfferCodeOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeOneTimeUseCodes]", r.fieldsSubscriptionOfferCodeOneTimeUseCodes, "form", "csv")
	}
	if r.fieldsSubscriptionOfferCodeCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodeCustomCodes]", r.fieldsSubscriptionOfferCodeCustomCodes, "form", "csv")
	}
	if r.fieldsSubscriptionOfferCodePrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionOfferCodePrices]", r.fieldsSubscriptionOfferCodePrices, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitOneTimeUseCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[oneTimeUseCodes]", r.limitOneTimeUseCodes, "form", "")
	}
	if r.limitCustomCodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[customCodes]", r.limitCustomCodes, "form", "")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricePointsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	filterTerritory *[]string
	fieldsSubscriptionPricePoints *[]string
	fieldsTerritories *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPricePointsGetToManyRelatedRequest) Execute() (*SubscriptionPricePointsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricePointsGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricePointsGetToManyRelated Method for SubscriptionsPricePointsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPricePointsGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPricePointsGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPricePointsGetToManyRelatedRequest {
	return ApiSubscriptionsPricePointsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricePointsResponse
func (a *SubscriptionsAPIService) SubscriptionsPricePointsGetToManyRelatedExecute(r ApiSubscriptionsPricePointsGetToManyRelatedRequest) (*SubscriptionPricePointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricePointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPricePointsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/pricePoints"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	subscriptionPricesLinkagesRequest *SubscriptionPricesLinkagesRequest
}

// List of related linkages
func (r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) SubscriptionPricesLinkagesRequest(subscriptionPricesLinkagesRequest SubscriptionPricesLinkagesRequest) ApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	r.subscriptionPricesLinkagesRequest = &subscriptionPricesLinkagesRequest
	return r
}

func (r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.SubscriptionsPricesDeleteToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesDeleteToManyRelationship Method for SubscriptionsPricesDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPricesDeleteToManyRelationshipRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPricesDeleteToManyRelationship(ctx context.Context, id string) ApiSubscriptionsPricesDeleteToManyRelationshipRequest {
	return ApiSubscriptionsPricesDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SubscriptionsAPIService) SubscriptionsPricesDeleteToManyRelationshipExecute(r ApiSubscriptionsPricesDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPricesDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionPricesLinkagesRequest == nil {
		return nil, reportError("subscriptionPricesLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionPricesLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	filterSubscriptionPricePoint *[]string
	filterTerritory *[]string
	fieldsSubscriptionPrices *[]string
	fieldsTerritories *[]string
	fieldsSubscriptionPricePoints *[]string
	limit *int32
	include *[]string
}

// filter by id(s) of related &#39;subscriptionPricePoint&#39;
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FilterSubscriptionPricePoint(filterSubscriptionPricePoint []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterSubscriptionPricePoint = &filterSubscriptionPricePoint
	return r
}

// filter by id(s) of related &#39;territory&#39;
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPrices
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPrices(fieldsSubscriptionPrices []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPrices = &fieldsSubscriptionPrices
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// the fields to include for returned resources of type subscriptionPricePoints
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) FieldsSubscriptionPricePoints(fieldsSubscriptionPricePoints []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.fieldsSubscriptionPricePoints = &fieldsSubscriptionPricePoints
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsPricesGetToManyRelatedRequest) Execute() (*SubscriptionPricesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelatedExecute(r)
}

/*
SubscriptionsPricesGetToManyRelated Method for SubscriptionsPricesGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPricesGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPricesGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPricesGetToManyRelatedRequest {
	return ApiSubscriptionsPricesGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricesResponse
func (a *SubscriptionsAPIService) SubscriptionsPricesGetToManyRelatedExecute(r ApiSubscriptionsPricesGetToManyRelatedRequest) (*SubscriptionPricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPricesGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterSubscriptionPricePoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[subscriptionPricePoint]", r.filterSubscriptionPricePoint, "form", "csv")
	}
	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsSubscriptionPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPrices]", r.fieldsSubscriptionPrices, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.fieldsSubscriptionPricePoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPricePoints]", r.fieldsSubscriptionPricePoints, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPricesGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	limit *int32
}

// maximum resources per page
func (r ApiSubscriptionsPricesGetToManyRelationshipRequest) Limit(limit int32) ApiSubscriptionsPricesGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiSubscriptionsPricesGetToManyRelationshipRequest) Execute() (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPricesGetToManyRelationshipExecute(r)
}

/*
SubscriptionsPricesGetToManyRelationship Method for SubscriptionsPricesGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPricesGetToManyRelationshipRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPricesGetToManyRelationship(ctx context.Context, id string) ApiSubscriptionsPricesGetToManyRelationshipRequest {
	return ApiSubscriptionsPricesGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPricesLinkagesResponse
func (a *SubscriptionsAPIService) SubscriptionsPricesGetToManyRelationshipExecute(r ApiSubscriptionsPricesGetToManyRelationshipRequest) (*SubscriptionPricesLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPricesLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPricesGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/relationships/prices"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsPromotedPurchases *[]string
	fieldsInAppPurchases *[]string
	fieldsSubscriptions *[]string
	fieldsPromotedPurchaseImages *[]string
	include *[]string
	limitPromotionImages *int32
}

// the fields to include for returned resources of type promotedPurchases
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchases(fieldsPromotedPurchases []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchases = &fieldsPromotedPurchases
	return r
}

// the fields to include for returned resources of type inAppPurchases
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsInAppPurchases(fieldsInAppPurchases []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsInAppPurchases = &fieldsInAppPurchases
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type promotedPurchaseImages
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) FieldsPromotedPurchaseImages(fieldsPromotedPurchaseImages []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.fieldsPromotedPurchaseImages = &fieldsPromotedPurchaseImages
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related promotionImages returned (when they are included)
// Deprecated
func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) LimitPromotionImages(limitPromotionImages int32) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	r.limitPromotionImages = &limitPromotionImages
	return r
}

func (r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) Execute() (*PromotedPurchaseResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r)
}

/*
SubscriptionsPromotedPurchaseGetToOneRelated Method for SubscriptionsPromotedPurchaseGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPromotedPurchaseGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest {
	return ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PromotedPurchaseResponse
func (a *SubscriptionsAPIService) SubscriptionsPromotedPurchaseGetToOneRelatedExecute(r ApiSubscriptionsPromotedPurchaseGetToOneRelatedRequest) (*PromotedPurchaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromotedPurchaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPromotedPurchaseGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotedPurchase"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsPromotedPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchases]", r.fieldsPromotedPurchases, "form", "csv")
	}
	if r.fieldsInAppPurchases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[inAppPurchases]", r.fieldsInAppPurchases, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsPromotedPurchaseImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[promotedPurchaseImages]", r.fieldsPromotedPurchaseImages, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPromotionImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[promotionImages]", r.limitPromotionImages, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	filterTerritory *[]string
	fieldsSubscriptionPromotionalOffers *[]string
	fieldsSubscriptions *[]string
	fieldsSubscriptionPromotionalOfferPrices *[]string
	limit *int32
	include *[]string
	limitPrices *int32
}

// filter by territory
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FilterTerritory(filterTerritory []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.filterTerritory = &filterTerritory
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOffers
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOffers(fieldsSubscriptionPromotionalOffers []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOffers = &fieldsSubscriptionPromotionalOffers
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type subscriptionPromotionalOfferPrices
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) FieldsSubscriptionPromotionalOfferPrices(fieldsSubscriptionPromotionalOfferPrices []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.fieldsSubscriptionPromotionalOfferPrices = &fieldsSubscriptionPromotionalOfferPrices
	return r
}

// maximum resources per page
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) LimitPrices(limitPrices int32) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

func (r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) Execute() (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsPromotionalOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsPromotionalOffersGetToManyRelated Method for SubscriptionsPromotionalOffersGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsPromotionalOffersGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest {
	return ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionPromotionalOffersResponse
func (a *SubscriptionsAPIService) SubscriptionsPromotionalOffersGetToManyRelatedExecute(r ApiSubscriptionsPromotionalOffersGetToManyRelatedRequest) (*SubscriptionPromotionalOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionPromotionalOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsPromotionalOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/promotionalOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTerritory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[territory]", r.filterTerritory, "form", "csv")
	}
	if r.fieldsSubscriptionPromotionalOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOffers]", r.fieldsSubscriptionPromotionalOffers, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsSubscriptionPromotionalOfferPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionPromotionalOfferPrices]", r.fieldsSubscriptionPromotionalOfferPrices, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsSubscriptionAvailabilities *[]string
	fieldsSubscriptions *[]string
	fieldsTerritories *[]string
	include *[]string
	limitAvailableTerritories *int32
}

// the fields to include for returned resources of type subscriptionAvailabilities
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsSubscriptionAvailabilities(fieldsSubscriptionAvailabilities []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsSubscriptionAvailabilities = &fieldsSubscriptionAvailabilities
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// the fields to include for returned resources of type territories
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) FieldsTerritories(fieldsTerritories []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.fieldsTerritories = &fieldsTerritories
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) Include(include []string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related availableTerritories returned (when they are included)
func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) LimitAvailableTerritories(limitAvailableTerritories int32) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	r.limitAvailableTerritories = &limitAvailableTerritories
	return r
}

func (r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) Execute() (*SubscriptionAvailabilityResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionAvailabilityGetToOneRelatedExecute(r)
}

/*
SubscriptionsSubscriptionAvailabilityGetToOneRelated Method for SubscriptionsSubscriptionAvailabilityGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsSubscriptionAvailabilityGetToOneRelated(ctx context.Context, id string) ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest {
	return ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionAvailabilityResponse
func (a *SubscriptionsAPIService) SubscriptionsSubscriptionAvailabilityGetToOneRelatedExecute(r ApiSubscriptionsSubscriptionAvailabilityGetToOneRelatedRequest) (*SubscriptionAvailabilityResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionAvailabilityResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsSubscriptionAvailabilityGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/subscriptionAvailability"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionAvailabilities != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionAvailabilities]", r.fieldsSubscriptionAvailabilities, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.fieldsTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[territories]", r.fieldsTerritories, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAvailableTerritories != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[availableTerritories]", r.limitAvailableTerritories, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsSubscriptionLocalizations *[]string
	fieldsSubscriptions *[]string
	limit *int32
	include *[]string
}

// the fields to include for returned resources of type subscriptionLocalizations
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptionLocalizations(fieldsSubscriptionLocalizations []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptionLocalizations = &fieldsSubscriptionLocalizations
	return r
}

// the fields to include for returned resources of type subscriptions
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) FieldsSubscriptions(fieldsSubscriptions []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.fieldsSubscriptions = &fieldsSubscriptions
	return r
}

// maximum resources per page
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	r.include = &include
	return r
}

func (r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) Execute() (*SubscriptionLocalizationsResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r)
}

/*
SubscriptionsSubscriptionLocalizationsGetToManyRelated Method for SubscriptionsSubscriptionLocalizationsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsSubscriptionLocalizationsGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest {
	return ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionLocalizationsResponse
func (a *SubscriptionsAPIService) SubscriptionsSubscriptionLocalizationsGetToManyRelatedExecute(r ApiSubscriptionsSubscriptionLocalizationsGetToManyRelatedRequest) (*SubscriptionLocalizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionLocalizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsSubscriptionLocalizationsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/subscriptionLocalizations"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsSubscriptionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptionLocalizations]", r.fieldsSubscriptionLocalizations, "form", "csv")
	}
	if r.fieldsSubscriptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[subscriptions]", r.fieldsSubscriptions, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	subscriptionUpdateRequest *SubscriptionUpdateRequest
}

// Subscription representation
func (r ApiSubscriptionsUpdateInstanceRequest) SubscriptionUpdateRequest(subscriptionUpdateRequest SubscriptionUpdateRequest) ApiSubscriptionsUpdateInstanceRequest {
	r.subscriptionUpdateRequest = &subscriptionUpdateRequest
	return r
}

func (r ApiSubscriptionsUpdateInstanceRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsUpdateInstanceExecute(r)
}

/*
SubscriptionsUpdateInstance Method for SubscriptionsUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsUpdateInstanceRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsUpdateInstance(ctx context.Context, id string) ApiSubscriptionsUpdateInstanceRequest {
	return ApiSubscriptionsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *SubscriptionsAPIService) SubscriptionsUpdateInstanceExecute(r ApiSubscriptionsUpdateInstanceRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("subscriptionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscriptionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubscriptionsWinBackOffersGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *SubscriptionsAPIService
	id string
	fieldsWinBackOffers *[]string
	fieldsWinBackOfferPrices *[]string
	limit *int32
	include *[]string
	limitPrices *int32
}

// the fields to include for returned resources of type winBackOffers
func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) FieldsWinBackOffers(fieldsWinBackOffers []string) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	r.fieldsWinBackOffers = &fieldsWinBackOffers
	return r
}

// the fields to include for returned resources of type winBackOfferPrices
func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) FieldsWinBackOfferPrices(fieldsWinBackOfferPrices []string) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	r.fieldsWinBackOfferPrices = &fieldsWinBackOfferPrices
	return r
}

// maximum resources per page
func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) Limit(limit int32) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) Include(include []string) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related prices returned (when they are included)
func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) LimitPrices(limitPrices int32) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	r.limitPrices = &limitPrices
	return r
}

func (r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) Execute() (*WinBackOffersResponse, *http.Response, error) {
	return r.ApiService.SubscriptionsWinBackOffersGetToManyRelatedExecute(r)
}

/*
SubscriptionsWinBackOffersGetToManyRelated Method for SubscriptionsWinBackOffersGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiSubscriptionsWinBackOffersGetToManyRelatedRequest
*/
func (a *SubscriptionsAPIService) SubscriptionsWinBackOffersGetToManyRelated(ctx context.Context, id string) ApiSubscriptionsWinBackOffersGetToManyRelatedRequest {
	return ApiSubscriptionsWinBackOffersGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return WinBackOffersResponse
func (a *SubscriptionsAPIService) SubscriptionsWinBackOffersGetToManyRelatedExecute(r ApiSubscriptionsWinBackOffersGetToManyRelatedRequest) (*WinBackOffersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WinBackOffersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionsAPIService.SubscriptionsWinBackOffersGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/subscriptions/{id}/winBackOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsWinBackOffers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[winBackOffers]", r.fieldsWinBackOffers, "form", "csv")
	}
	if r.fieldsWinBackOfferPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[winBackOfferPrices]", r.fieldsWinBackOfferPrices, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitPrices != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[prices]", r.limitPrices, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
