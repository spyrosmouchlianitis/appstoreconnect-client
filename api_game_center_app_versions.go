/*
App Store Connect API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.6.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package appstoreconnect-client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// GameCenterAppVersionsAPIService GameCenterAppVersionsAPI service
type GameCenterAppVersionsAPIService service

type ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	fieldsAppStoreVersions *[]string
	fieldsApps *[]string
	fieldsAgeRatingDeclarations *[]string
	fieldsAppStoreVersionLocalizations *[]string
	fieldsBuilds *[]string
	fieldsAppStoreVersionPhasedReleases *[]string
	fieldsGameCenterAppVersions *[]string
	fieldsRoutingAppCoverages *[]string
	fieldsAppStoreReviewDetails *[]string
	fieldsAppStoreVersionSubmissions *[]string
	fieldsAppClipDefaultExperiences *[]string
	fieldsAppStoreVersionExperiments *[]string
	fieldsAlternativeDistributionPackages *[]string
	include *[]string
	limitAppStoreVersionLocalizations *int32
	limitAppStoreVersionExperiments *int32
	limitAppStoreVersionExperimentsV2 *int32
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// the fields to include for returned resources of type apps
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsApps(fieldsApps []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsApps = &fieldsApps
	return r
}

// the fields to include for returned resources of type ageRatingDeclarations
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAgeRatingDeclarations(fieldsAgeRatingDeclarations []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAgeRatingDeclarations = &fieldsAgeRatingDeclarations
	return r
}

// the fields to include for returned resources of type appStoreVersionLocalizations
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreVersionLocalizations(fieldsAppStoreVersionLocalizations []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreVersionLocalizations = &fieldsAppStoreVersionLocalizations
	return r
}

// the fields to include for returned resources of type builds
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsBuilds(fieldsBuilds []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsBuilds = &fieldsBuilds
	return r
}

// the fields to include for returned resources of type appStoreVersionPhasedReleases
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreVersionPhasedReleases(fieldsAppStoreVersionPhasedReleases []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreVersionPhasedReleases = &fieldsAppStoreVersionPhasedReleases
	return r
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type routingAppCoverages
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsRoutingAppCoverages(fieldsRoutingAppCoverages []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsRoutingAppCoverages = &fieldsRoutingAppCoverages
	return r
}

// the fields to include for returned resources of type appStoreReviewDetails
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreReviewDetails(fieldsAppStoreReviewDetails []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreReviewDetails = &fieldsAppStoreReviewDetails
	return r
}

// the fields to include for returned resources of type appStoreVersionSubmissions
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreVersionSubmissions(fieldsAppStoreVersionSubmissions []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreVersionSubmissions = &fieldsAppStoreVersionSubmissions
	return r
}

// the fields to include for returned resources of type appClipDefaultExperiences
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppClipDefaultExperiences(fieldsAppClipDefaultExperiences []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppClipDefaultExperiences = &fieldsAppClipDefaultExperiences
	return r
}

// the fields to include for returned resources of type appStoreVersionExperiments
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAppStoreVersionExperiments(fieldsAppStoreVersionExperiments []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAppStoreVersionExperiments = &fieldsAppStoreVersionExperiments
	return r
}

// the fields to include for returned resources of type alternativeDistributionPackages
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) FieldsAlternativeDistributionPackages(fieldsAlternativeDistributionPackages []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.fieldsAlternativeDistributionPackages = &fieldsAlternativeDistributionPackages
	return r
}

// comma-separated list of relationships to include
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) Include(include []string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related appStoreVersionLocalizations returned (when they are included)
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) LimitAppStoreVersionLocalizations(limitAppStoreVersionLocalizations int32) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.limitAppStoreVersionLocalizations = &limitAppStoreVersionLocalizations
	return r
}

// maximum number of related appStoreVersionExperiments returned (when they are included)
// Deprecated
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) LimitAppStoreVersionExperiments(limitAppStoreVersionExperiments int32) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.limitAppStoreVersionExperiments = &limitAppStoreVersionExperiments
	return r
}

// maximum number of related appStoreVersionExperimentsV2 returned (when they are included)
func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) LimitAppStoreVersionExperimentsV2(limitAppStoreVersionExperimentsV2 int32) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	r.limitAppStoreVersionExperimentsV2 = &limitAppStoreVersionExperimentsV2
	return r
}

func (r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) Execute() (*AppStoreVersionResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsAppStoreVersionGetToOneRelatedExecute(r)
}

/*
GameCenterAppVersionsAppStoreVersionGetToOneRelated Method for GameCenterAppVersionsAppStoreVersionGetToOneRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsAppStoreVersionGetToOneRelated(ctx context.Context, id string) ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest {
	return ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AppStoreVersionResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsAppStoreVersionGetToOneRelatedExecute(r ApiGameCenterAppVersionsAppStoreVersionGetToOneRelatedRequest) (*AppStoreVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AppStoreVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsAppStoreVersionGetToOneRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}/appStoreVersion"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.fieldsApps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[apps]", r.fieldsApps, "form", "csv")
	}
	if r.fieldsAgeRatingDeclarations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[ageRatingDeclarations]", r.fieldsAgeRatingDeclarations, "form", "csv")
	}
	if r.fieldsAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionLocalizations]", r.fieldsAppStoreVersionLocalizations, "form", "csv")
	}
	if r.fieldsBuilds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[builds]", r.fieldsBuilds, "form", "csv")
	}
	if r.fieldsAppStoreVersionPhasedReleases != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionPhasedReleases]", r.fieldsAppStoreVersionPhasedReleases, "form", "csv")
	}
	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "form", "csv")
	}
	if r.fieldsRoutingAppCoverages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[routingAppCoverages]", r.fieldsRoutingAppCoverages, "form", "csv")
	}
	if r.fieldsAppStoreReviewDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreReviewDetails]", r.fieldsAppStoreReviewDetails, "form", "csv")
	}
	if r.fieldsAppStoreVersionSubmissions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionSubmissions]", r.fieldsAppStoreVersionSubmissions, "form", "csv")
	}
	if r.fieldsAppClipDefaultExperiences != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appClipDefaultExperiences]", r.fieldsAppClipDefaultExperiences, "form", "csv")
	}
	if r.fieldsAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersionExperiments]", r.fieldsAppStoreVersionExperiments, "form", "csv")
	}
	if r.fieldsAlternativeDistributionPackages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[alternativeDistributionPackages]", r.fieldsAlternativeDistributionPackages, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitAppStoreVersionLocalizations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionLocalizations]", r.limitAppStoreVersionLocalizations, "form", "")
	}
	if r.limitAppStoreVersionExperiments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperiments]", r.limitAppStoreVersionExperiments, "form", "")
	}
	if r.limitAppStoreVersionExperimentsV2 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[appStoreVersionExperimentsV2]", r.limitAppStoreVersionExperimentsV2, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	gameCenterAppVersionCompatibilityVersionsLinkagesRequest *GameCenterAppVersionCompatibilityVersionsLinkagesRequest
}

// List of related linkages
func (r ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest) GameCenterAppVersionCompatibilityVersionsLinkagesRequest(gameCenterAppVersionCompatibilityVersionsLinkagesRequest GameCenterAppVersionCompatibilityVersionsLinkagesRequest) ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest {
	r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest = &gameCenterAppVersionCompatibilityVersionsLinkagesRequest
	return r
}

func (r ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipExecute(r)
}

/*
GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship Method for GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship(ctx context.Context, id string) ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest {
	return ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipExecute(r ApiGameCenterAppVersionsCompatibilityVersionsCreateToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsCompatibilityVersionsCreateToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest == nil {
		return nil, reportError("gameCenterAppVersionCompatibilityVersionsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	gameCenterAppVersionCompatibilityVersionsLinkagesRequest *GameCenterAppVersionCompatibilityVersionsLinkagesRequest
}

// List of related linkages
func (r ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest) GameCenterAppVersionCompatibilityVersionsLinkagesRequest(gameCenterAppVersionCompatibilityVersionsLinkagesRequest GameCenterAppVersionCompatibilityVersionsLinkagesRequest) ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest {
	r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest = &gameCenterAppVersionCompatibilityVersionsLinkagesRequest
	return r
}

func (r ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest) Execute() (*http.Response, error) {
	return r.ApiService.GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipExecute(r)
}

/*
GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship Method for GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship(ctx context.Context, id string) ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest {
	return ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipExecute(r ApiGameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationshipRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsCompatibilityVersionsDeleteToManyRelationship")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest == nil {
		return nil, reportError("gameCenterAppVersionCompatibilityVersionsLinkagesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gameCenterAppVersionCompatibilityVersionsLinkagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	filterEnabled *[]string
	fieldsGameCenterAppVersions *[]string
	fieldsAppStoreVersions *[]string
	limit *int32
	include *[]string
	limitCompatibilityVersions *int32
}

// filter by attribute &#39;enabled&#39;
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) FilterEnabled(filterEnabled []string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.filterEnabled = &filterEnabled
	return r
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// maximum resources per page
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) Limit(limit int32) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.limit = &limit
	return r
}

// comma-separated list of relationships to include
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) Include(include []string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.include = &include
	return r
}

// maximum number of related compatibilityVersions returned (when they are included)
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) LimitCompatibilityVersions(limitCompatibilityVersions int32) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	r.limitCompatibilityVersions = &limitCompatibilityVersions
	return r
}

func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) Execute() (*GameCenterAppVersionsResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsCompatibilityVersionsGetToManyRelatedExecute(r)
}

/*
GameCenterAppVersionsCompatibilityVersionsGetToManyRelated Method for GameCenterAppVersionsCompatibilityVersionsGetToManyRelated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsGetToManyRelated(ctx context.Context, id string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest {
	return ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterAppVersionsResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsGetToManyRelatedExecute(r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelatedRequest) (*GameCenterAppVersionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterAppVersionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsCompatibilityVersionsGetToManyRelated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}/compatibilityVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterEnabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter[enabled]", r.filterEnabled, "form", "csv")
	}
	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitCompatibilityVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[compatibilityVersions]", r.limitCompatibilityVersions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	limit *int32
}

// maximum resources per page
func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest) Limit(limit int32) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest {
	r.limit = &limit
	return r
}

func (r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest) Execute() (*GameCenterAppVersionCompatibilityVersionsLinkagesResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipExecute(r)
}

/*
GameCenterAppVersionsCompatibilityVersionsGetToManyRelationship Method for GameCenterAppVersionsCompatibilityVersionsGetToManyRelationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsGetToManyRelationship(ctx context.Context, id string) ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest {
	return ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterAppVersionCompatibilityVersionsLinkagesResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipExecute(r ApiGameCenterAppVersionsCompatibilityVersionsGetToManyRelationshipRequest) (*GameCenterAppVersionCompatibilityVersionsLinkagesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterAppVersionCompatibilityVersionsLinkagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsCompatibilityVersionsGetToManyRelationship")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}/relationships/compatibilityVersions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsCreateInstanceRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	gameCenterAppVersionCreateRequest *GameCenterAppVersionCreateRequest
}

// GameCenterAppVersion representation
func (r ApiGameCenterAppVersionsCreateInstanceRequest) GameCenterAppVersionCreateRequest(gameCenterAppVersionCreateRequest GameCenterAppVersionCreateRequest) ApiGameCenterAppVersionsCreateInstanceRequest {
	r.gameCenterAppVersionCreateRequest = &gameCenterAppVersionCreateRequest
	return r
}

func (r ApiGameCenterAppVersionsCreateInstanceRequest) Execute() (*GameCenterAppVersionResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsCreateInstanceExecute(r)
}

/*
GameCenterAppVersionsCreateInstance Method for GameCenterAppVersionsCreateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGameCenterAppVersionsCreateInstanceRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCreateInstance(ctx context.Context) ApiGameCenterAppVersionsCreateInstanceRequest {
	return ApiGameCenterAppVersionsCreateInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GameCenterAppVersionResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsCreateInstanceExecute(r ApiGameCenterAppVersionsCreateInstanceRequest) (*GameCenterAppVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterAppVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsCreateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gameCenterAppVersionCreateRequest == nil {
		return localVarReturnValue, nil, reportError("gameCenterAppVersionCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gameCenterAppVersionCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsGetInstanceRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	fieldsGameCenterAppVersions *[]string
	fieldsAppStoreVersions *[]string
	include *[]string
	limitCompatibilityVersions *int32
}

// the fields to include for returned resources of type gameCenterAppVersions
func (r ApiGameCenterAppVersionsGetInstanceRequest) FieldsGameCenterAppVersions(fieldsGameCenterAppVersions []string) ApiGameCenterAppVersionsGetInstanceRequest {
	r.fieldsGameCenterAppVersions = &fieldsGameCenterAppVersions
	return r
}

// the fields to include for returned resources of type appStoreVersions
func (r ApiGameCenterAppVersionsGetInstanceRequest) FieldsAppStoreVersions(fieldsAppStoreVersions []string) ApiGameCenterAppVersionsGetInstanceRequest {
	r.fieldsAppStoreVersions = &fieldsAppStoreVersions
	return r
}

// comma-separated list of relationships to include
func (r ApiGameCenterAppVersionsGetInstanceRequest) Include(include []string) ApiGameCenterAppVersionsGetInstanceRequest {
	r.include = &include
	return r
}

// maximum number of related compatibilityVersions returned (when they are included)
func (r ApiGameCenterAppVersionsGetInstanceRequest) LimitCompatibilityVersions(limitCompatibilityVersions int32) ApiGameCenterAppVersionsGetInstanceRequest {
	r.limitCompatibilityVersions = &limitCompatibilityVersions
	return r
}

func (r ApiGameCenterAppVersionsGetInstanceRequest) Execute() (*GameCenterAppVersionResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsGetInstanceExecute(r)
}

/*
GameCenterAppVersionsGetInstance Method for GameCenterAppVersionsGetInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsGetInstanceRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsGetInstance(ctx context.Context, id string) ApiGameCenterAppVersionsGetInstanceRequest {
	return ApiGameCenterAppVersionsGetInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterAppVersionResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsGetInstanceExecute(r ApiGameCenterAppVersionsGetInstanceRequest) (*GameCenterAppVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterAppVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsGetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fieldsGameCenterAppVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[gameCenterAppVersions]", r.fieldsGameCenterAppVersions, "form", "csv")
	}
	if r.fieldsAppStoreVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields[appStoreVersions]", r.fieldsAppStoreVersions, "form", "csv")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "form", "csv")
	}
	if r.limitCompatibilityVersions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit[compatibilityVersions]", r.limitCompatibilityVersions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGameCenterAppVersionsUpdateInstanceRequest struct {
	ctx context.Context
	ApiService *GameCenterAppVersionsAPIService
	id string
	gameCenterAppVersionUpdateRequest *GameCenterAppVersionUpdateRequest
}

// GameCenterAppVersion representation
func (r ApiGameCenterAppVersionsUpdateInstanceRequest) GameCenterAppVersionUpdateRequest(gameCenterAppVersionUpdateRequest GameCenterAppVersionUpdateRequest) ApiGameCenterAppVersionsUpdateInstanceRequest {
	r.gameCenterAppVersionUpdateRequest = &gameCenterAppVersionUpdateRequest
	return r
}

func (r ApiGameCenterAppVersionsUpdateInstanceRequest) Execute() (*GameCenterAppVersionResponse, *http.Response, error) {
	return r.ApiService.GameCenterAppVersionsUpdateInstanceExecute(r)
}

/*
GameCenterAppVersionsUpdateInstance Method for GameCenterAppVersionsUpdateInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id the id of the requested resource
 @return ApiGameCenterAppVersionsUpdateInstanceRequest
*/
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsUpdateInstance(ctx context.Context, id string) ApiGameCenterAppVersionsUpdateInstanceRequest {
	return ApiGameCenterAppVersionsUpdateInstanceRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GameCenterAppVersionResponse
func (a *GameCenterAppVersionsAPIService) GameCenterAppVersionsUpdateInstanceExecute(r ApiGameCenterAppVersionsUpdateInstanceRequest) (*GameCenterAppVersionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GameCenterAppVersionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GameCenterAppVersionsAPIService.GameCenterAppVersionsUpdateInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/gameCenterAppVersions/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gameCenterAppVersionUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("gameCenterAppVersionUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.gameCenterAppVersionUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
